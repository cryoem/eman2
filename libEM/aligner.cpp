/**
 * $Id$
 */

/*
 * Author: Steven Ludtke, 04/10/2003 (sludtke@bcm.edu)
 * Copyright (c) 2000-2006 Baylor College of Medicine
 *
 * This software is issued under a joint BSD/GNU license. You may use the
 * source code in this file under either license. However, note that the
 * complete EMAN2 and SPARX software packages have some GPL dependencies,
 * so you are responsible for compliance with the licenses of these packages
 * if you opt to use BSD licensing. The warranty disclaimer below holds
 * in either instance.
 *
 * This complete copyright notice must be included in any revised version of the
 * source code. Additional authorship citations may be added, but existing
 * author citations must be preserved.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * */
#include "emfft.h"
#include "cmp.h"
#include "aligner.h"
#include "emdata.h"
#include "processor.h"
#include "util.h"
#include "symmetry.h"
#include <gsl/gsl_multimin.h>
#include "plugins/aligner_template.h"

#ifdef EMAN2_USING_CUDA
	#include "cuda/cuda_processor.h"
	#include "cuda/cuda_cmp.h"
#endif

#ifdef SPARX_USING_CUDA
	#include <sparx/cuda/cuda_ccf.h>
#endif

#define EMAN2_ALIGNER_DEBUG 0

using namespace EMAN;

const string TranslationalAligner::NAME = "translational";
const string RotationalAligner::NAME = "rotational";
const string RotationalAlignerIterative::NAME = "rotational_iterative";
const string RotatePrecenterAligner::NAME = "rotate_precenter";
const string RotateTranslateAligner::NAME = "rotate_translate";
const string RotateTranslateAlignerIterative::NAME = "rotate_translate_iterative";
const string RotateTranslateAlignerPawel::NAME = "rotate_translate_resample";
const string RotateTranslateBestAligner::NAME = "rotate_translate_best";
const string RotateFlipAligner::NAME = "rotate_flip";
const string RotateFlipAlignerIterative::NAME = "rotate_flip.iterative";
const string RotateTranslateFlipAligner::NAME = "rotate_translate_flip";
const string RotateTranslateFlipAlignerIterative::NAME = "rotate_translate_flip_iterative";
const string RotateTranslateFlipAlignerPawel::NAME = "rotate_translate_flip_resample";
const string RTFExhaustiveAligner::NAME = "rtf_exhaustive";
const string RTFSlowExhaustiveAligner::NAME = "rtf_slow_exhaustive";
const string RefineAligner::NAME = "refine";
const string Refine3DAlignerGrid::NAME = "refine_3d_grid";
const string Refine3DAlignerQuaternion::NAME = "refine_3d";
const string RT3DGridAligner::NAME = "rotate_translate_3d_grid";
const string RT3DSphereAligner::NAME = "rotate_translate_3d";
const string RT3DSymmetryAligner::NAME = "rotate_symmetry_3d";
const string FRM2DAligner::NAME = "frm2d";


template <> Factory < Aligner >::Factory()
{
	force_add<TranslationalAligner>();
	force_add<RotationalAligner>();
	force_add<RotationalAlignerIterative>();
	force_add<RotatePrecenterAligner>();
	force_add<RotateTranslateAligner>();
	force_add<RotateTranslateAlignerIterative>();
	force_add<RotateTranslateAlignerPawel>();
	force_add<RotateFlipAligner>();
	force_add<RotateFlipAlignerIterative>();
	force_add<RotateTranslateFlipAligner>();
	force_add<RotateTranslateFlipAlignerIterative>();
	force_add<RotateTranslateFlipAlignerPawel>();
	force_add<RTFExhaustiveAligner>();
	force_add<RTFSlowExhaustiveAligner>();
	force_add<RefineAligner>();
	force_add<Refine3DAlignerGrid>();
	force_add<Refine3DAlignerQuaternion>();
	force_add<RT3DGridAligner>();
	force_add<RT3DSphereAligner>();
	force_add<RT3DSymmetryAligner>();
	force_add<FRM2DAligner>();
//	force_add<XYZAligner>();
}

vector<Dict> Aligner::xform_align_nbest(EMData *, EMData *, const unsigned int, const string &, const Dict&) const
{
	vector<Dict> solns;
	return solns;
}

// Note, the translational aligner assumes that the correlation image
// generated by the calc_ccf function is centered on the bottom left corner
// That is, if you did at calc_cff using identical images, the
// peak would be at 0,0
EMData *TranslationalAligner::align(EMData * this_img, EMData *to,
					const string&, const Dict&) const
{
	if (!this_img) {
		return 0;
	}

	if (to && !EMUtil::is_same_size(this_img, to))
		throw ImageDimensionException("Images must be the same size to perform translational alignment");

	EMData *cf = 0;
	int nx = this_img->get_xsize();
	int ny = this_img->get_ysize();
	int nz = this_img->get_zsize();

	int masked = params.set_default("masked",0);
	int useflcf = params.set_default("useflcf",0);
	bool use_cpu = true;

#ifdef EMAN2_USING_CUDA
	if(EMData::usecuda == 1) {
		if(!this_img->getcudarwdata()) this_img->copy_to_cuda();
		if(to && !to->getcudarwdata()) to->copy_to_cuda();
		if (masked) throw UnexpectedBehaviorException("Masked is not yet supported in CUDA");
		if (useflcf) throw UnexpectedBehaviorException("Useflcf is not yet supported in CUDA");
 		//cout << "Translate on GPU" << endl;
		use_cpu = false;
		cf = this_img->calc_ccf(to);
	}
#endif // EMAN2_USING_CUDA
	
	if (use_cpu) {
		if (useflcf) cf = this_img->calc_flcf(to);
		else cf = this_img->calc_ccf(to);
	}
	//return cf;
	// This is too expensive, esp for CUDA(we we can fix later
	if (masked) {
		EMData *msk=this_img->process("threshold.notzero");
		EMData *sqr=to->process("math.squared");
		EMData *cfn=msk->calc_ccf(sqr);
		cfn->process_inplace("math.sqrt");
		float *d1=cf->get_data();
		float *d2=cfn->get_data();
		for (size_t i=0; i<(size_t)nx*ny*nz; ++i) {
			if (d2[i]!=0) d1[i]/=d2[i];
		}
		cf->update();
		delete msk;
		delete sqr;
		delete cfn;
	}

	int maxshiftx = params.set_default("maxshift",-1);
	int maxshifty = params["maxshift"];
	int maxshiftz = params["maxshift"];
	int nozero = params["nozero"];

	if (maxshiftx <= 0) {
		maxshiftx = nx / 4;
		maxshifty = ny / 4;
		maxshiftz = nz / 4;
	}

	if (maxshiftx > nx / 2 - 1) maxshiftx = nx / 2 - 1;
	if (maxshifty > ny / 2 - 1)	maxshifty = ny / 2 - 1;
	if (maxshiftz > nz / 2 - 1) maxshiftz = nz / 2 - 1;

	if (nx == 1) maxshiftx = 0; // This is justhere for completeness really... plus it saves errors
	if (ny == 1) maxshifty = 0;
	if (nz == 1) maxshiftz = 0;

	// If nozero the portion of the image in the center (and its 8-connected neighborhood) is zeroed
	if (nozero) {
		cf->zero_corner_circulant(1);
	}
	
	IntPoint peak;
#ifdef EMAN2_USING_CUDA
	if (!use_cpu) {
		if (nozero) throw UnexpectedBehaviorException("Nozero is not yet supported in CUDA");
		CudaPeakInfo* data = calc_max_location_wrap_cuda(cf->getcudarwdata(), cf->get_xsize(), cf->get_ysize(), cf->get_zsize(), maxshiftx, maxshifty, maxshiftz);
		peak = IntPoint(data->px,data->py,data->pz);
		free(data);
	}
#endif // EMAN2_USING_CUDA
	
	if (use_cpu) {
		peak = cf->calc_max_location_wrap(maxshiftx, maxshifty, maxshiftz);
	}
	//cout << -peak[0] << " " << -peak[1] << " " << -peak[2] << endl;
	Vec3f cur_trans = Vec3f ( (float)-peak[0], (float)-peak[1], (float)-peak[2]);
	//cout << peak[0] << " " << peak[1] << endl;

	if (!to) {
		cur_trans /= 2.0f; // If aligning theimage to itself then only go half way -
		int intonly = params.set_default("intonly",false);
		if (intonly) {
			cur_trans[0] = floor(cur_trans[0] + 0.5f);
			cur_trans[1] = floor(cur_trans[1] + 0.5f);
			cur_trans[2] = floor(cur_trans[2] + 0.5f);
		}
	}

	if( cf ){
		delete cf;
		cf = 0;
	}
	
	Dict params("trans",static_cast< vector<int> >(cur_trans));
	if (use_cpu){
		cf=this_img->process("math.translate.int",params);
	}
	Transform t;
	t.set_trans(cur_trans);
	
#ifdef EMAN2_USING_CUDA
	if (!use_cpu) {
		//this will work just fine....
		cf = this_img->process("xform",Dict("transform",&t));
	}
#endif // EMAN2_USING_CUDA

	if ( nz != 1 ) {
//		Transform* t = get_set_align_attr("xform.align3d",cf,this_img);
//		t->set_trans(cur_trans);
		cf->set_attr("xform.align3d",&t);
	} else if ( ny != 1 ) {
		//Transform* t = get_set_align_attr("xform.align2d",cf,this_img);
		cur_trans[2] = 0; // just make sure of it
		t.set_trans(cur_trans);
		cf->set_attr("xform.align2d",&t);
	}

	return cf;
}

EMData * RotationalAligner::align_180_ambiguous(EMData * this_img, EMData * to, int rfp_mode) {

	// Make translationally invariant rotational footprints
	EMData* this_img_rfp, * to_rfp;
	if (rfp_mode == 0) {
		this_img_rfp = this_img->make_rotational_footprint_e1();
		to_rfp = to->make_rotational_footprint_e1();
	} else if (rfp_mode == 1) {
		this_img_rfp = this_img->make_rotational_footprint();
		to_rfp = to->make_rotational_footprint();
	} else if (rfp_mode == 2) {
		this_img_rfp = this_img->make_rotational_footprint_cmc();
		to_rfp = to->make_rotational_footprint_cmc();
	} else {
		throw InvalidParameterException("rfp_mode must be 0,1 or 2");
	}
	int this_img_rfp_nx = this_img_rfp->get_xsize();

	// Do row-wise correlation, returning a sum.
	EMData *cf = this_img_rfp->calc_ccfx(to_rfp, 0, this_img->get_ysize());
	
	// Delete them, they're no longer needed
	delete this_img_rfp; this_img_rfp = 0;
	delete to_rfp; to_rfp = 0;

	// Now solve the rotational alignment by finding the max in the column sum
	float *data = cf->get_data();
	
	float peak = 0;
	int peak_index = 0;
	Util::find_max(data, this_img_rfp_nx, &peak, &peak_index);

	if( cf ) {
		delete cf;
		cf = 0;
	}
	float rot_angle = (float) (peak_index * 180.0f / this_img_rfp_nx);

	// Return the result
	Transform tmp(Dict("type","2d","alpha",rot_angle));
	cf=this_img->process("xform",Dict("transform",(Transform*)&tmp));
//	Transform* t = get_set_align_attr("xform.align2d",cf,this_img);
//	Dict d("type","2d","alpha",rot_angle);
//	t->set_rotation(d);
	cf->set_attr("xform.align2d",&tmp);
	return cf;
}

EMData *RotationalAligner::align(EMData * this_img, EMData *to,
			const string& cmp_name, const Dict& cmp_params) const
{
	if (!to) throw InvalidParameterException("Can not rotational align - the image to align to is NULL");
	
#ifdef EMAN2_USING_CUDA
	if(EMData::usecuda == 1) {
		if(!this_img->getcudarwdata()) this_img->copy_to_cuda();
		if(!to->getcudarwdata()) to->copy_to_cuda();
	}
#endif

	// Perform 180 ambiguous alignment
	int rfp_mode = params.set_default("rfp_mode",0);
	EMData* rot_aligned = RotationalAligner::align_180_ambiguous(this_img,to,rfp_mode);
	Transform * tmp = rot_aligned->get_attr("xform.align2d");
	Dict rot = tmp->get_rotation("2d");
	float rotate_angle_solution = rot["alpha"];
	delete tmp;

	EMData *rot_align_180 = rot_aligned->process("math.rotate.180");

	// Generate the comparison metrics for both rotational candidates
	float rot_cmp = rot_aligned->cmp(cmp_name, to, cmp_params);
	float rot_180_cmp = rot_align_180->cmp(cmp_name, to, cmp_params);

	// Decide on the result
	float score = 0.0;
	EMData* result = NULL;
	if (rot_cmp < rot_180_cmp){
		result = rot_aligned;
		score = rot_cmp;
		delete rot_align_180; rot_align_180 = 0;
	} else {
		result = rot_align_180;
		score = rot_180_cmp;
		delete rot_aligned; rot_aligned = 0;
		rotate_angle_solution = rotate_angle_solution-180.0f;
	}

//	Transform* t = get_align_attr("xform.align2d",result);
//	t->set_rotation(Dict("type","2d","alpha",rotate_angle_solution));
	Transform tmp2(Dict("type","2d","alpha",rotate_angle_solution));
	result->set_attr("xform.align2d",&tmp2);
	return result;
}


EMData *RotatePrecenterAligner::align(EMData * this_img, EMData *to,
			const string&, const Dict&) const
{
	if (!to) {
		return 0;
	}

	int ny = this_img->get_ysize();
	int size = Util::calc_best_fft_size((int) (M_PI * ny * 1.5));
	EMData *e1 = this_img->unwrap(4, ny * 7 / 16, size, 0, 0, 1);
	EMData *e2 = to->unwrap(4, ny * 7 / 16, size, 0, 0, 1);
	EMData *cf = e1->calc_ccfx(e2, 0, ny);

	float *data = cf->get_data();

	float peak = 0;
	int peak_index = 0;
	Util::find_max(data, size, &peak, &peak_index);
	float a = (float) ((1.0f - 1.0f * peak_index / size) * 180. * 2);

	Transform rot;
	rot.set_rotation(Dict("type","2d","alpha",(float)(a*180./M_PI)));
	EMData* rslt = this_img->process("xform",Dict("transform",&rot));
	rslt->set_attr("xform.align2d",&rot);
//
//	Transform* t = get_set_align_attr("xform.align2d",rslt,this_img);
//	t->set_rotation(Dict("type","2d","alpha",-a));
//
//	EMData* result this_img->transform(Dict("type","2d","alpha",(float)(a*180./M_PI)));
//
//	cf->set_attr("xform.align2d",t);
//	delete t;
//	cf->update();

	if( e1 )
	{
		delete e1;
		e1 = 0;
	}

	if( e2 )
	{
		delete e2;
		e2 = 0;
	}

	if (cf) {
		delete cf;
		cf = 0;
	}
	return rslt;
}

EMData *RotationalAlignerIterative::align(EMData * this_img, EMData *to,
			const string &, const Dict&) const
{
	int r1 = params.set_default("r1",-1);
	int r2 = params.set_default("r2",-1);
	//to start lest try the original size image. If needed, we can pad it....
	EMData * to_polar = to->unwrap(r1,r2,-1,0,0,true);
	EMData * this_img_polar = this_img->unwrap(r1,r2,-1,0,0,true);
	int this_img_polar_nx = this_img_polar->get_xsize();
	
	EMData *cf = this_img_polar->calc_ccfx(to_polar, 0, this_img->get_ysize());
	
	//take out the garbage
	delete to_polar; to_polar = 0;
	delete this_img_polar; this_img_polar = 0;
	
	float *data = cf->get_data();
	float peak = 0;
	int peak_index = 0;
	Util::find_max(data, this_img_polar_nx, &peak, &peak_index);

	delete cf; cf = 0;
	float rot_angle = (float) (peak_index * 360.0f / this_img_polar_nx);
	
	//return the result
	//cout << rot_angle << endl;
	Transform tmp(Dict("type","2d","alpha",rot_angle));
	EMData * rotimg=this_img->process("xform",Dict("transform",(Transform*)&tmp));
	rotimg->set_attr("xform.align2d",&tmp);
	
	return rotimg;
	
}

EMData *RotateTranslateAlignerIterative::align(EMData * this_img, EMData *to,
			const string & cmp_name, const Dict& cmp_params) const
{
	int maxiter = params.set_default("maxiter", 3);
	
	Dict trans_params;
	trans_params["intonly"] = 0;
	trans_params["maxshift"] = params.set_default("maxshift", -1);
	trans_params["useflcf"] = params.set_default("useflcf",0);
	trans_params["nozero"] = params.set_default("nozero",false);
	
	Dict rot_params;
	rot_params["r1"] = params.set_default("r1", -1);
	rot_params["r2"] = params.set_default("r2", -1);
	
	Transform t;
	EMData * moving_img = this_img;
	for(int it = 0; it < maxiter; it++){
		
		// First do a translational alignment
		EMData * trans_align = moving_img->align("translational", to, trans_params, cmp_name, cmp_params);
		Transform * tt = trans_align->get_attr("xform.align2d");
		t = *tt*t;
		delete tt;

		//now do rotation
		EMData * rottrans_align = trans_align->align("rotational.iterative", to, rot_params, cmp_name, cmp_params);
		Transform * rt = rottrans_align->get_attr("xform.align2d");
		t = *rt*t;
		delete trans_align; trans_align = 0;
		delete rottrans_align; rottrans_align = 0;
		delete rt;
		
		//this minimizes interpolation errors (all images that are futher processed will be interpolated at most twice)
		if(it > 0){delete moving_img;}
		
		moving_img = this_img->process("xform",Dict("transform",&t));  //iterate
	}
	
	//write the total transformation;	
	moving_img->set_attr("xform.align2d", &t);
	
	return moving_img;
}

EMData *RotateTranslateAlignerPawel::align(EMData * this_img, EMData *to,
			const string & cmp_name, const Dict& cmp_params) const
{
	if (cmp_name != "dot" && cmp_name != "ccc") throw InvalidParameterException("Resample aligner only works for dot and ccc");
	
	int maxtx = params.set_default("tx", 0);
	int maxty = params.set_default("ty", 0);
	int r1 = params.set_default("r1",-1);
	int r2 = params.set_default("r2",-1);
	
	if(this_img->get_xsize()/2 - 1 - r2 - maxtx <= 0 || (r2 == -1 && maxtx > 0)) throw InvalidParameterException("nx/2 - 1 - r2 - tx must be greater than or = 0");
	if(this_img->get_ysize()/2 - 1 - r2 - maxty <= 0 || (r2 == -1 && maxty > 0)) throw InvalidParameterException("ny/2 - 1 - r2 - ty must be greater than or = 0");
	
	float best_peak = -numeric_limits<float>::infinity();
	int best_peak_index = 0;
	int best_tx = 0;
	int best_ty = 0;
	int polarxsize = 0;
		
	for(int x = -maxtx; x <= maxtx; x++){
		for(int y = -maxty; y <= maxty; y++){

			EMData * to_polar = to->unwrap(r1,r2,-1,0,0,true);
			EMData * this_img_polar = this_img->unwrap(r1,r2,-1,x,y,true);
			EMData * cf = this_img_polar->calc_ccfx(to_polar, 0, this_img_polar->get_ysize());
			
			polarxsize = this_img_polar->get_xsize();
			
			//take out the garbage
			delete to_polar; to_polar = 0;
			delete this_img_polar; this_img_polar = 0;
	
			float *data = cf->get_data();
			float peak = 0;
			int peak_index = 0;
			Util::find_max(data, polarxsize, &peak, &peak_index);
			delete cf; cf = 0;

			if(peak > best_peak) {
				best_peak = peak;
				best_peak_index = peak_index;
				best_tx = x;
				best_ty = y;
			}
		}
	}
	
	float rot_angle = (float) (best_peak_index * 360.0f / polarxsize);
				
	//return the result
	Transform tmp(Dict("type","2d","alpha",rot_angle,"tx",best_tx,"ty",best_ty));
	EMData* rotimg=this_img->process("xform",Dict("transform",(Transform*)&tmp));
	rotimg->set_attr("xform.align2d",&tmp);
	
	return rotimg;
	
}

EMData *RotateTranslateAligner::align(EMData * this_img, EMData *to,
			const string & cmp_name, const Dict& cmp_params) const
{

#ifdef EMAN2_USING_CUDA
	if(EMData::usecuda == 1) {
		if(!this_img->getcudarwdata()) this_img->copy_to_cuda();
		if(!to->getcudarwdata()) to->copy_to_cuda();
	}
#endif

	// Get the 180 degree ambiguously rotationally aligned and its 180 degree rotation counterpart
	int rfp_mode = params.set_default("rfp_mode",0);
	EMData *rot_align  =  RotationalAligner::align_180_ambiguous(this_img,to,rfp_mode);
	Transform * tmp = rot_align->get_attr("xform.align2d");
	Dict rot = tmp->get_rotation("2d");
	float rotate_angle_solution = rot["alpha"];
	delete tmp;

	EMData *rot_align_180 = rot_align->copy();
	rot_align_180->process_inplace("math.rotate.180");

	Dict trans_params;
	trans_params["intonly"]  = 0;
	trans_params["maxshift"] = params.set_default("maxshift", -1);
	trans_params["useflcf"]=params.set_default("useflcf",0);

	// Do the first case translational alignment
	trans_params["nozero"]   = params.set_default("nozero",false);
	EMData* rot_trans = rot_align->align("translational", to, trans_params, cmp_name, cmp_params);
	if( rot_align ) { // Clean up
		delete rot_align;
		rot_align = 0;
	}

	// Do the second case translational alignment
	EMData*  rot_180_trans = rot_align_180->align("translational", to, trans_params, cmp_name, cmp_params);
	if( rot_align_180 )	{ // Clean up
		delete rot_align_180;
		rot_align_180 = 0;
	}

	// Finally decide on the result
	float cmp1 = rot_trans->cmp(cmp_name, to, cmp_params);
	float cmp2 = rot_180_trans->cmp(cmp_name, to, cmp_params);

	EMData *result = 0;
	if (cmp1 < cmp2) { // Assumes smaller is better - thus all comparitors should support "smaller is better"
		if( rot_180_trans )	{
			delete rot_180_trans;
			rot_180_trans = 0;
		}
		result = rot_trans;
	}
	else {
		if( rot_trans )	{
			delete rot_trans;
			rot_trans = 0;
		}
		result = rot_180_trans;
		rotate_angle_solution -= 180.f;
	}

	Transform* t = result->get_attr("xform.align2d");
	t->set_rotation(Dict("type","2d","alpha",rotate_angle_solution));
	result->set_attr("xform.align2d",t);
	delete t;

	return result;
}




EMData* RotateTranslateFlipAligner::align(EMData * this_img, EMData *to,
										  const string & cmp_name, const Dict& cmp_params) const
{
	// Get the non flipped rotational, tranlsationally aligned image
	Dict rt_params("maxshift", params["maxshift"], "rfp_mode", params.set_default("rfp_mode",0),"useflcf",params.set_default("useflcf",0));
	EMData *rot_trans_align = this_img->align("rotate_translate",to,rt_params,cmp_name, cmp_params);
	
	// Do the same alignment, but using the flipped version of the image
	EMData *flipped = params.set_default("flip", (EMData *) 0);
	bool delete_flag = false;
	if (flipped == 0) {
		flipped = to->process("xform.flip", Dict("axis", "x"));
		delete_flag = true;
	}

	EMData * rot_trans_align_flip = this_img->align("rotate_translate", flipped, rt_params, cmp_name, cmp_params);
	Transform* t = rot_trans_align_flip->get_attr("xform.align2d");
	t->set_mirror(true);
	rot_trans_align_flip->set_attr("xform.align2d",t);
	delete t;

	// Now finally decide on what is the best answer
	float cmp1 = rot_trans_align->cmp(cmp_name, to, cmp_params);
	float cmp2 = rot_trans_align_flip->cmp(cmp_name, flipped, cmp_params);

	if (delete_flag){
		if(flipped) {
			delete flipped;
			flipped = 0;
		}
	}

	EMData *result = 0;
	if (cmp1 < cmp2 )  {

		if( rot_trans_align_flip ) {
			delete rot_trans_align_flip;
			rot_trans_align_flip = 0;
		}
		result = rot_trans_align;
	}
	else {
		if( rot_trans_align ) {
			delete rot_trans_align;
			rot_trans_align = 0;
		}
		result = rot_trans_align_flip;
		result->process_inplace("xform.flip",Dict("axis","x"));
	}

	return result;
}

EMData* RotateTranslateFlipAlignerIterative::align(EMData * this_img, EMData *to,
										  const string & cmp_name, const Dict& cmp_params) const
{
	// Get the non flipped rotational, tranlsationally aligned image
	Dict rt_params("maxshift", params["maxshift"],"r1",params.set_default("r1",-1),"r2",params.set_default("r2",-1));
	EMData *rot_trans_align = this_img->align("rotate_translate.iterative",to,rt_params,cmp_name, cmp_params);

	// Do the same alignment, but using the flipped version of the image
	EMData *flipped = params.set_default("flip", (EMData *) 0);
	bool delete_flag = false;
	if (flipped == 0) {
		flipped = to->process("xform.flip", Dict("axis", "x"));
		delete_flag = true;
	}

	EMData * rot_trans_align_flip = this_img->align("rotate_translate.iterative", flipped, rt_params, cmp_name, cmp_params);
	Transform* t = rot_trans_align_flip->get_attr("xform.align2d");
	t->set_mirror(true);
	rot_trans_align_flip->set_attr("xform.align2d",t);
	delete t;

	// Now finally decide on what is the best answer
	float cmp1 = rot_trans_align->cmp(cmp_name, to, cmp_params);
	float cmp2 = rot_trans_align_flip->cmp(cmp_name, flipped, cmp_params);

	if (delete_flag){
		if(flipped) {
			delete flipped;
			flipped = 0;
		}
	}

	EMData *result = 0;
	if (cmp1 < cmp2 )  {

		if( rot_trans_align_flip ) {
			delete rot_trans_align_flip;
			rot_trans_align_flip = 0;
		}
		result = rot_trans_align;
	}
	else {
		if( rot_trans_align ) {
			delete rot_trans_align;
			rot_trans_align = 0;
		}
		result = rot_trans_align_flip;
		result->process_inplace("xform.flip",Dict("axis","x"));
	}

	return result;
}

EMData *RotateTranslateFlipAlignerPawel::align(EMData * this_img, EMData *to,
			const string & cmp_name, const Dict& cmp_params) const
{
	if (cmp_name != "dot" && cmp_name != "ccc") throw InvalidParameterException("Resample aligner only works for dot and ccc");
	
	int maxtx = params.set_default("tx", 0);
	int maxty = params.set_default("ty", 0);
	int r1 = params.set_default("r1",-1);
	int r2 = params.set_default("r2",-1);
	
	if(this_img->get_xsize()/2 - 1 - r2 - maxtx <= 0 || (r2 == -1 && maxtx > 0)) throw InvalidParameterException("nx/2 - 1 - r2 - tx must be greater than or = 0");
	if(this_img->get_ysize()/2 - 1 - r2 - maxty <= 0 || (r2 == -1 && maxty > 0)) throw InvalidParameterException("ny/2 - 1 - r2 - ty must be greater than or = 0");
	
	float best_peak = -numeric_limits<float>::infinity();
	int best_peak_index = 0;
	int best_tx = 0;
	int best_ty = 0;
	int polarxsize = 0;
	bool flip = false;
	
	for(int x = -maxtx; x <= maxtx; x++){
		for(int y = -maxty; y <= maxty; y++){

			EMData * to_polar = to->unwrap(r1,r2,-1,0,0,true);
			EMData * this_img_polar = this_img->unwrap(r1,r2,-1,x,y,true);
			EMData * cfflip = this_img_polar->calc_ccfx(to_polar, 0, this_img_polar->get_ysize(), false, true);
			EMData * cf = this_img_polar->calc_ccfx(to_polar, 0, this_img_polar->get_ysize());
			
			polarxsize = this_img_polar->get_xsize();
			
			//take out the garbage
			delete to_polar; to_polar = 0;
			delete this_img_polar; this_img_polar = 0;
	
			float *data = cf->get_data();
			float peak = 0;
			int peak_index = 0;
			Util::find_max(data, polarxsize, &peak, &peak_index);
			delete cf; cf = 0;

			if(peak > best_peak) {
				best_peak = peak;
				best_peak_index = peak_index;
				best_tx = x;
				best_ty = y;
				flip = false;
			}
			
			data = cfflip->get_data();
			Util::find_max(data, polarxsize, &peak, &peak_index);
			delete cfflip; cfflip = 0;

			if(peak > best_peak) {
				best_peak = peak;
				best_peak_index = peak_index;
				best_tx = x;
				best_ty = y;
				flip = true;
			}
		}
	}
	
	float rot_angle = (float) (best_peak_index * 360.0f / polarxsize);
				
	//return the result
	Transform tmp(Dict("type","2d","alpha",rot_angle,"tx",best_tx,"ty",best_ty));
	EMData* rotimg=this_img->process("xform",Dict("transform",(Transform*)&tmp));
	rotimg->set_attr("xform.align2d",&tmp);
	if(flip == true) {
		rotimg->process_inplace("xform.flip",Dict("axis", "x"));
	}
	
	return rotimg;
	
}

EMData *RotateFlipAligner::align(EMData * this_img, EMData *to,
			const string& cmp_name, const Dict& cmp_params) const
{
	Dict rot_params("rfp_mode",params.set_default("rfp_mode",0));
	EMData *r1 = this_img->align("rotational", to, rot_params,cmp_name, cmp_params);


	EMData* flipped =to->process("xform.flip", Dict("axis", "x"));
	EMData *r2 = this_img->align("rotational", flipped,rot_params, cmp_name, cmp_params);
	Transform* t = r2->get_attr("xform.align2d");
	t->set_mirror(true);
	r2->set_attr("xform.align2d",t);
	delete t;

	float cmp1 = r1->cmp(cmp_name, to, cmp_params);
	float cmp2 = r2->cmp(cmp_name, flipped, cmp_params);

	delete flipped; flipped = 0;

	EMData *result = 0;

	if (cmp1 < cmp2) {
		if( r2 )
		{
			delete r2;
			r2 = 0;
		}
		result = r1;
	}
	else {
		if( r1 )
		{
			delete r1;
			r1 = 0;
		}
		result = r2;
		result->process_inplace("xform.flip",Dict("axis","x"));
	}

	return result;
}

EMData *RotateFlipAlignerIterative::align(EMData * this_img, EMData *to,
			const string& cmp_name, const Dict& cmp_params) const
{
	Dict rot_params("r1",params.set_default("r1",-1),"r2",params.set_default("r2",-1));
	EMData *r1 = this_img->align("rotational.iterative", to, rot_params,cmp_name, cmp_params);

	EMData* flipped =to->process("xform.flip", Dict("axis", "x"));
	EMData *r2 = this_img->align("rotational.iterative", flipped,rot_params, cmp_name, cmp_params);
	Transform* t = r2->get_attr("xform.align2d");
	t->set_mirror(true);
	r2->set_attr("xform.align2d",t);
	delete t;

	float cmp1 = r1->cmp(cmp_name, to, cmp_params);
	float cmp2 = r2->cmp(cmp_name, flipped, cmp_params);

	delete flipped; flipped = 0;

	EMData *result = 0;

	if (cmp1 < cmp2) {
		if( r2 )
		{
			delete r2;
			r2 = 0;
		}
		result = r1;
	}
	else {
		if( r1 )
		{
			delete r1;
			r1 = 0;
		}
		result = r2;
		result->process_inplace("xform.flip",Dict("axis","x"));
	}

	return result;
}

// David Woolford says FIXME
// You will note the excessive amount of EMData copying that's going in this function
// This is because functions that are operating on the EMData objects are changing them
// and if you do not use copies the whole algorithm breaks. I did not have time to go
// through and rectify this situation.
// David Woolford says - this problem is related to the fact that many functions that
// take EMData pointers as arguments do not take them as constant pointers to constant
// objects, instead they are treated as raw (completely changeable) pointers. This means
// it's hard to track down which functions are changing the EMData objects, because they
// all do (in name). If this behavior is unavoidable then ignore this comment, however if possible it would
// be good to make things const as much as possible. For example in alignment, technically
// the argument EMData objects (raw pointers) should not be altered... should they?
//
// But const can be very annoying sometimes...
EMData *RTFExhaustiveAligner::align(EMData * this_img, EMData *to,
			const string & cmp_name, const Dict& cmp_params) const
{
	EMData *flip = params.set_default("flip", (EMData *) 0);
	int maxshift = params.set_default("maxshift", this_img->get_xsize()/8);
	if (maxshift < 2) throw InvalidParameterException("maxshift must be greater than or equal to 2");

	int ny = this_img->get_ysize();
	int xst = (int) floor(2 * M_PI * ny);
	xst = Util::calc_best_fft_size(xst);

	Dict d("n",2);
	EMData *to_shrunk_unwrapped = to->process("math.medianshrink",d);

	int to_copy_r2 = to_shrunk_unwrapped->get_ysize() / 2 - 2 - maxshift / 2;
	EMData *tmp = to_shrunk_unwrapped->unwrap(4, to_copy_r2, xst / 2, 0, 0, true);
	if( to_shrunk_unwrapped )
	{
		delete to_shrunk_unwrapped;
		to_shrunk_unwrapped = 0;
	}
	to_shrunk_unwrapped = tmp;

	EMData *to_shrunk_unwrapped_copy = to_shrunk_unwrapped->copy();
	EMData* to_unwrapped = to->unwrap(4, to->get_ysize() / 2 - 2 - maxshift, xst, 0, 0, true);
	EMData *to_unwrapped_copy = to_unwrapped->copy();

	bool delete_flipped = true;
	EMData *flipped = 0;
	if (flip) {
		delete_flipped = false;
		flipped = flip;
	}
	else {
		flipped = to->process("xform.flip", Dict("axis", "x"));
	}
	EMData *to_shrunk_flipped_unwrapped = flipped->process("math.medianshrink",d);
	tmp = to_shrunk_flipped_unwrapped->unwrap(4, to_copy_r2, xst / 2, 0, 0, true);
	if( to_shrunk_flipped_unwrapped )
	{
		delete to_shrunk_flipped_unwrapped;
		to_shrunk_flipped_unwrapped = 0;
	}
	to_shrunk_flipped_unwrapped = tmp;
	EMData *to_shrunk_flipped_unwrapped_copy = to_shrunk_flipped_unwrapped->copy();
	EMData* to_flip_unwrapped = flipped->unwrap(4, to->get_ysize() / 2 - 2 - maxshift, xst, 0, 0, true);
	EMData* to_flip_unwrapped_copy = to_flip_unwrapped->copy();

	if (delete_flipped && flipped != 0) {
		delete flipped;
		flipped = 0;
	}

	EMData *this_shrunk_2 = this_img->process("math.medianshrink",d);

	float bestval = FLT_MAX;
	float bestang = 0;
	int bestflip = 0;
	float bestdx = 0;
	float bestdy = 0;

	int half_maxshift = maxshift / 2;

	int ur2 = this_shrunk_2->get_ysize() / 2 - 2 - half_maxshift;
	for (int dy = -half_maxshift; dy <= half_maxshift; dy += 1) {
		for (int dx = -half_maxshift; dx <= half_maxshift; dx += 1) {
#ifdef	_WIN32
			if (_hypot(dx, dy) <= half_maxshift) {
#else
			if (hypot(dx, dy) <= half_maxshift) {
#endif
				EMData *uw = this_shrunk_2->unwrap(4, ur2, xst / 2, dx, dy, true);
				EMData *uwc = uw->copy();
				EMData *a = uw->calc_ccfx(to_shrunk_unwrapped);

				uwc->rotate_x(a->calc_max_index());
				float cm = uwc->cmp(cmp_name, to_shrunk_unwrapped_copy, cmp_params);
				if (cm < bestval) {
					bestval = cm;
					bestang = (float) (2.0 * M_PI * a->calc_max_index() / a->get_xsize());
					bestdx = (float)dx;
					bestdy = (float)dy;
					bestflip = 0;
				}


				if( a )
				{
					delete a;
					a = 0;
				}
				if( uw )
				{
					delete uw;
					uw = 0;
				}
				if( uwc )
				{
					delete uwc;
					uwc = 0;
				}
				uw = this_shrunk_2->unwrap(4, ur2, xst / 2, dx, dy, true);
				uwc = uw->copy();
				a = uw->calc_ccfx(to_shrunk_flipped_unwrapped);

				uwc->rotate_x(a->calc_max_index());
				cm = uwc->cmp(cmp_name, to_shrunk_flipped_unwrapped_copy, cmp_params);
				if (cm < bestval) {
					bestval = cm;
					bestang = (float) (2.0 * M_PI * a->calc_max_index() / a->get_xsize());
					bestdx = (float)dx;
					bestdy = (float)dy;
					bestflip = 1;
				}

				if( a )
				{
					delete a;
					a = 0;
				}

				if( uw )
				{
					delete uw;
					uw = 0;
				}
				if( uwc )
				{
					delete uwc;
					uwc = 0;
				}
			}
		}
	}
	if( this_shrunk_2 )
	{
		delete this_shrunk_2;
		this_shrunk_2 = 0;
	}
	if( to_shrunk_unwrapped )
	{
		delete to_shrunk_unwrapped;
		to_shrunk_unwrapped = 0;
	}
	if( to_shrunk_unwrapped_copy )
	{
		delete to_shrunk_unwrapped_copy;
		to_shrunk_unwrapped_copy = 0;
	}
	if( to_shrunk_flipped_unwrapped )
	{
		delete to_shrunk_flipped_unwrapped;
		to_shrunk_flipped_unwrapped = 0;
	}
	if( to_shrunk_flipped_unwrapped_copy )
	{
		delete to_shrunk_flipped_unwrapped_copy;
		to_shrunk_flipped_unwrapped_copy = 0;
	}
	bestdx *= 2;
	bestdy *= 2;
	bestval = FLT_MAX;

	float bestdx2 = bestdx;
	float bestdy2 = bestdy;
	// Note I tried steps less than 1.0 (sub pixel precision) and it actually appeared detrimental
	// So my advice is to stick with dx += 1.0 etc unless you really are looking to fine tune this
	// algorithm
	for (float dy = bestdy2 - 3; dy <= bestdy2 + 3; dy += 1.0 ) {
		for (float dx = bestdx2 - 3; dx <= bestdx2 + 3; dx += 1.0 ) {

#ifdef	_WIN32
			if (_hypot(dx, dy) <= maxshift) {
#else
			if (hypot(dx, dy) <= maxshift) {
#endif
				EMData *uw = this_img->unwrap(4, this_img->get_ysize() / 2 - 2 - maxshift, xst, (int)dx, (int)dy, true);
				EMData *uwc = uw->copy();
				EMData *a = uw->calc_ccfx(to_unwrapped);

				uwc->rotate_x(a->calc_max_index());
				float cm = uwc->cmp(cmp_name, to_unwrapped_copy, cmp_params);

				if (cm < bestval) {
					bestval = cm;
					bestang = (float)(2.0 * M_PI * a->calc_max_index() / a->get_xsize());
					bestdx = dx;
					bestdy = dy;
					bestflip = 0;
				}

				if( a )
				{
					delete a;
					a = 0;
				}
				if( uw )
				{
					delete uw;
					uw = 0;
				}
				if( uwc )
				{
					delete uwc;
					uwc = 0;
				}
				uw = this_img->unwrap(4, this_img->get_ysize() / 2 - 2 - maxshift, xst, (int)dx, (int)dy, true);
				uwc = uw->copy();
				a = uw->calc_ccfx(to_flip_unwrapped);

				uwc->rotate_x(a->calc_max_index());
				cm = uwc->cmp(cmp_name, to_flip_unwrapped_copy, cmp_params);

				if (cm < bestval) {
					bestval = cm;
					bestang = (float)(2.0 * M_PI * a->calc_max_index() / a->get_xsize());
					bestdx = dx;
					bestdy = dy;
					bestflip = 1;
				}

				if( a )
				{
					delete a;
					a = 0;
				}
				if( uw )
				{
					delete uw;
					uw = 0;
				}
				if( uwc )
				{
					delete uwc;
					uwc = 0;
				}
			}
		}
	}
	if( to_unwrapped ) {delete to_unwrapped;to_unwrapped = 0;}
	if( to_shrunk_unwrapped ) {	delete to_shrunk_unwrapped;	to_shrunk_unwrapped = 0;}
	if (to_unwrapped_copy) { delete to_unwrapped_copy; to_unwrapped_copy = 0; }
	if (to_flip_unwrapped) { delete to_flip_unwrapped; to_flip_unwrapped = 0; }
	if (to_flip_unwrapped_copy) { delete to_flip_unwrapped_copy; to_flip_unwrapped_copy = 0;}

	bestang *= (float)EMConsts::rad2deg;
	Transform t(Dict("type","2d","alpha",(float)bestang));
	t.set_pre_trans(Vec2f(-bestdx,-bestdy));
	if (bestflip) {
		t.set_mirror(true);
	}

	EMData* ret = this_img->process("xform",Dict("transform",&t));
	ret->set_attr("xform.align2d",&t);

	return ret;
}


EMData *RTFSlowExhaustiveAligner::align(EMData * this_img, EMData *to,
			const string & cmp_name, const Dict& cmp_params) const
{

	EMData *flip = params.set_default("flip", (EMData *) 0);
	int maxshift = params.set_default("maxshift", -1);

	EMData *flipped = 0;

	bool delete_flipped = true;
	if (flip) {
		delete_flipped = false;
		flipped = flip;
	}
	else {
		flipped = to->process("xform.flip", Dict("axis", "x"));
	}

	int nx = this_img->get_xsize();

	if (maxshift < 0) {
		maxshift = nx / 10;
	}

	float angle_step =  params.set_default("angstep", 0.0f);
	if ( angle_step == 0 ) angle_step = atan2(2.0f, (float)nx);
	else {
		angle_step *= (float)EMConsts::deg2rad; //convert to radians
	}
	float trans_step =  params.set_default("transtep",1.0f);

	if (trans_step <= 0) throw InvalidParameterException("transstep must be greater than 0");
	if (angle_step <= 0) throw InvalidParameterException("angstep must be greater than 0");


	Dict shrinkfactor("n",2);
	EMData *this_img_shrink = this_img->process("math.medianshrink",shrinkfactor);
	EMData *to_shrunk = to->process("math.medianshrink",shrinkfactor);
	EMData *flipped_shrunk = flipped->process("math.medianshrink",shrinkfactor);

	int bestflip = 0;
	float bestdx = 0;
	float bestdy = 0;

	float bestang = 0;
	float bestval = FLT_MAX;

	int half_maxshift = maxshift / 2;


	for (int dy = -half_maxshift; dy <= half_maxshift; ++dy) {
		for (int dx = -half_maxshift; dx <= half_maxshift; ++dx) {
			if (hypot(dx, dy) <= maxshift) {
				for (float ang = -angle_step * 2.0f; ang <= (float)2 * M_PI; ang += angle_step * 4.0f) {
					EMData v(*this_img_shrink);
					Transform t(Dict("type","2d","alpha",static_cast<float>(ang*EMConsts::rad2deg)));
					t.set_trans((float)dx,(float)dy);
					v.transform(t);
// 					v.rotate_translate(ang*EMConsts::rad2deg, 0.0f, 0.0f, (float)dx, (float)dy, 0.0f);

					float lc = v.cmp(cmp_name, to_shrunk, cmp_params);

					if (lc < bestval) {
						bestval = lc;
						bestang = ang;
						bestdx = (float)dx;
						bestdy = (float)dy;
						bestflip = 0;
					}

					lc = v.cmp(cmp_name,flipped_shrunk , cmp_params);
					if (lc < bestval) {
						bestval = lc;
						bestang = ang;
						bestdx = (float)dx;
						bestdy = (float)dy;
						bestflip = 1;
					}
				}
			}
		}
	}

	if( to_shrunk )
	{
		delete to_shrunk;
		to_shrunk = 0;
	}
	if( flipped_shrunk )
	{
		delete flipped_shrunk;
		flipped_shrunk = 0;
	}
	if( this_img_shrink )
	{
		delete this_img_shrink;
		this_img_shrink = 0;
	}

	bestdx *= 2;
	bestdy *= 2;
	bestval = FLT_MAX;

	float bestdx2 = bestdx;
	float bestdy2 = bestdy;
	float bestang2 = bestang;

	for (float dy = bestdy2 - 3; dy <= bestdy2 + 3; dy += trans_step) {
		for (float dx = bestdx2 - 3; dx <= bestdx2 + 3; dx += trans_step) {
			if (hypot(dx, dy) <= maxshift) {
				for (float ang = bestang2 - angle_step * 6.0f; ang <= bestang2 + angle_step * 6.0f; ang += angle_step) {
					EMData v(*this_img);
					Transform t(Dict("type","2d","alpha",static_cast<float>(ang*EMConsts::rad2deg)));
					t.set_trans(dx,dy);
					v.transform(t);
// 					v.rotate_translate(ang*EMConsts::rad2deg, 0.0f, 0.0f, (float)dx, (float)dy, 0.0f);

					float lc = v.cmp(cmp_name, to, cmp_params);

					if (lc < bestval) {
						bestval = lc;
						bestang = ang;
						bestdx = dx;
						bestdy = dy;
						bestflip = 0;
					}

					lc = v.cmp(cmp_name, flipped, cmp_params);

					if (lc < bestval) {
						bestval = lc;
						bestang = ang;
						bestdx = dx;
						bestdy = dy;
						bestflip = 1;
					}
				}
			}
		}
	}

	if (delete_flipped) { delete flipped; flipped = 0; }

	bestang *= (float)EMConsts::rad2deg;
	Transform t(Dict("type","2d","alpha",(float)bestang));
	t.set_trans(bestdx,bestdy);

	if (bestflip) {
		t.set_mirror(true);
	}

	EMData* rslt = this_img->process("xform",Dict("transform",&t));
	rslt->set_attr("xform.align2d",&t);

	return rslt;
}



static double refalifn(const gsl_vector * v, void *params)
{
	Dict *dict = (Dict *) params;

	double x = gsl_vector_get(v, 0);
	double y = gsl_vector_get(v, 1);
	double a = gsl_vector_get(v, 2);

	EMData *this_img = (*dict)["this"];
	EMData *with = (*dict)["with"];
	bool mirror = (*dict)["mirror"];

//	float mean = (float)this_img->get_attr("mean");
//	if ( Util::goodf(&mean) ) {
//		//cout << "tmps mean is nan even before rotation" << endl;
//	}

	Transform t(Dict("type","2d","alpha",static_cast<float>(a)));
// 	Transform3D t3d(Transform3D::EMAN, (float)a, 0.0f, 0.0f);
// 	t3d.set_posttrans( (float) x, (float) y);
//	tmp->rotate_translate(t3d);
	t.set_trans((float)x,(float)y);
	t.set_mirror(mirror);
	if (v->size>3) {
		float sca=(float)gsl_vector_get(v, 3);
		if (sca<.7 || sca>1.3) return 1.0e20;
		t.set_scale((float)gsl_vector_get(v, 3));
	}
	EMData *tmp = this_img->process("xform",Dict("transform",&t));

//	printf("GSL %f %f %f %d %f\n",x,y,a,mirror,(float)gsl_vector_get(v, 3));
	Cmp* c = (Cmp*) ((void*)(*dict)["cmp"]);
	double result = c->cmp(tmp,with);

	// DELETE AT SOME STAGE, USEFUL FOR PRERELEASE STUFF
	// 	float test_result = (float)result;
// 	if ( Util::goodf(&test_result) ) {
//		cout << "result " << result << " " << x << " " << y << " " << a << endl;
//		cout << (float)this_img->get_attr("mean") << " " << (float)tmp->get_attr("mean") << " " << (float)with->get_attr("mean") << endl;
//		tmp->write_image("tmp.hdf");
//		with->write_image("with.hdf");
//		this_img->write_image("this_img.hdf");
//		EMData* t = this_img->copy();
//		cout << (float)t->get_attr("mean") << endl;
//		t->rotate_translate( t3d );
//		cout << (float)t->get_attr("mean") << endl;
//		cout << "exit" << endl;
//// 		double result = c->cmp(t,with);
//		cout << (float)t->get_attr("mean") << endl;
//		cout << "now exit" << endl;
//		delete t;
// 	}


	if ( tmp != 0 ) delete tmp;

	return result;
}

static double refalifnfast(const gsl_vector * v, void *params)
{
	Dict *dict = (Dict *) params;
	EMData *this_img = (*dict)["this"];
	EMData *img_to = (*dict)["with"];
	bool mirror = (*dict)["mirror"];

	double x = gsl_vector_get(v, 0);
	double y = gsl_vector_get(v, 1);
	double a = gsl_vector_get(v, 2);

	double r = this_img->dot_rotate_translate(img_to, (float)x, (float)y, (float)a, mirror);
	int nsec = this_img->get_xsize() * this_img->get_ysize();
	double result = 1.0 - r / nsec;

// 	cout << result << " x " << x << " y " << y << " az " << a <<  endl;
	return result;
}


EMData *RefineAligner::align(EMData * this_img, EMData *to,
	const string & cmp_name, const Dict& cmp_params) const
{

	if (!to) {
		return 0;
	}

	EMData *result;
	int mode = params.set_default("mode", 0);
	float saz = 0.0;
	float sdx = 0.0;
	float sdy = 0.0;
	float sscale = 1.0;
	bool mirror = false;
	Transform* t;
	if (params.has_key("xform.align2d") ) {
		t = params["xform.align2d"];
		Dict params = t->get_params("2d");
		saz = params["alpha"];
		sdx = params["tx"];
		sdy = params["ty"];
		mirror = params["mirror"];
		sscale = params["scale"];
	} else {
		t = new Transform(); // is the identity
	}

	// We do this to prevent the GSL routine from crashing on an invalid alignment
	if ((float)(this_img->get_attr("sigma"))==0.0 || (float)(to->get_attr("sigma"))==0.0) {
		result = this_img->process("xform",Dict("transform",t));
		result->set_attr("xform.align2d",t);
		delete t;
		return result;
	}
	
	float stepx = params.set_default("stepx",1.0f);
	float stepy = params.set_default("stepy",1.0f);
	// Default step is 5 degree - note in EMAN1 it was 0.1 radians
	float stepaz = params.set_default("stepaz",5.0f);
	float stepscale = params.set_default("stepscale",0.0f);

	int np = 3;
	if (stepscale!=0.0) np++;
	Dict gsl_params;
	gsl_params["this"] = this_img;
	gsl_params["with"] = to;
	gsl_params["snr"]  = params["snr"];
	gsl_params["mirror"] = mirror;

	const gsl_multimin_fminimizer_type *T = gsl_multimin_fminimizer_nmsimplex;
	gsl_vector *ss = gsl_vector_alloc(np);


	gsl_vector_set(ss, 0, stepx);
	gsl_vector_set(ss, 1, stepy);
	gsl_vector_set(ss, 2, stepaz);
	if (stepscale!=0.0) gsl_vector_set(ss,3,stepscale);
	
	gsl_vector *x = gsl_vector_alloc(np);
	gsl_vector_set(x, 0, sdx);
	gsl_vector_set(x, 1, sdy);
	gsl_vector_set(x, 2, saz);
	if (stepscale!=0.0) gsl_vector_set(x,3,1.0);
	
	Cmp *c = 0;

	gsl_multimin_function minex_func;
	if (mode == 2) {
		minex_func.f = &refalifnfast;
	}
	else {
		c = Factory < Cmp >::get(cmp_name, cmp_params);
		gsl_params["cmp"] = (void *) c;
		minex_func.f = &refalifn;
	}

	minex_func.n = np;
	minex_func.params = (void *) &gsl_params;

	gsl_multimin_fminimizer *s = gsl_multimin_fminimizer_alloc(T, np);
	gsl_multimin_fminimizer_set(s, &minex_func, x, ss);

	int rval = GSL_CONTINUE;
	int status = GSL_SUCCESS;
	int iter = 1;

	float precision = params.set_default("precision",0.04f);
	int maxiter = params.set_default("maxiter",28);

//	printf("Refine sx=%1.2f sy=%1.2f sa=%1.2f prec=%1.4f maxit=%d\n",stepx,stepy,stepaz,precision,maxiter);
//	printf("%1.2f %1.2f %1.1f  ->",(float)gsl_vector_get(s->x, 0),(float)gsl_vector_get(s->x, 1),(float)gsl_vector_get(s->x, 2));

	while (rval == GSL_CONTINUE && iter < maxiter) {
		iter++;
		status = gsl_multimin_fminimizer_iterate(s);
		if (status) {
			break;
		}
		rval = gsl_multimin_test_size(gsl_multimin_fminimizer_size(s), precision);
	}

	int maxshift = params.set_default("maxshift",-1);

	if (maxshift <= 0) {
		maxshift = this_img->get_xsize() / 4;
	}
	float fmaxshift = static_cast<float>(maxshift);
	if ( fmaxshift >= fabs((float)gsl_vector_get(s->x, 0)) && fmaxshift >= fabs((float)gsl_vector_get(s->x, 1)) && (stepscale==0 || (((float)gsl_vector_get(s->x, 3))<1.3 && ((float)gsl_vector_get(s->x, 3))<0.7))  )
	{
//		printf(" Refine good %1.2f %1.2f %1.1f\n",(float)gsl_vector_get(s->x, 0),(float)gsl_vector_get(s->x, 1),(float)gsl_vector_get(s->x, 2));
		Transform  tsoln(Dict("type","2d","alpha",(float)gsl_vector_get(s->x, 2)));
		tsoln.set_mirror(mirror);
		tsoln.set_trans((float)gsl_vector_get(s->x, 0),(float)gsl_vector_get(s->x, 1));
		if (stepscale!=0.0) tsoln.set_scale((float)gsl_vector_get(s->x, 3));
		result = this_img->process("xform",Dict("transform",&tsoln));
		result->set_attr("xform.align2d",&tsoln);
	} else { // The refine aligner failed - this shift went beyond the max shift
//		printf(" Refine Failed %1.2f %1.2f %1.1f\n",(float)gsl_vector_get(s->x, 0),(float)gsl_vector_get(s->x, 1),(float)gsl_vector_get(s->x, 2));
		result = this_img->process("xform",Dict("transform",t));
		result->set_attr("xform.align2d",t);
	}

	delete t;
	t = 0;

	gsl_vector_free(x);
	gsl_vector_free(ss);
	gsl_multimin_fminimizer_free(s);

	if ( c != 0 ) delete c;
	return result;
}

static Transform refalin3d_perturbquat(const Transform*const t, const float& spincoeff, const float& n0, const float& n1, const float& n2, const float& x, const float& y, const float& z)
{
	Vec3f normal(n0,n1,n2);
	normal.normalize();
	
	float omega = spincoeff*sqrt(n0*n0 + n1*n1 + n2*n2); // Here we compute the spin by the rotation axis vector length
	Dict d;
	d["type"] = "spin";
	d["Omega"] = omega;
	d["n1"] = normal[0];
	d["n2"] = normal[1];
	d["n3"] = normal[2];
	//cout << omega << " " << normal[0] << " " << normal[1] << " " << normal[2] << " " << n0 << " " << n1 << " " << n2 << endl;
	
	Transform q(d);
	q.set_trans((float)x,(float)y,(float)z);
	
	q = q*(*t); //compose transforms	
	
	return q;
}

static double refalifn3dquat(const gsl_vector * v, void *params)
{
	Dict *dict = (Dict *) params;

 	double n0 = gsl_vector_get(v, 0);
 	double n1 = gsl_vector_get(v, 1);
	double n2 = gsl_vector_get(v, 2);
	double x = gsl_vector_get(v, 3);
	double y = gsl_vector_get(v, 4);
	double z = gsl_vector_get(v, 5);

	EMData *this_img = (*dict)["this"];
	EMData *with = (*dict)["with"];
// 	bool mirror = (*dict)["mirror"];

	Transform* t = (*dict)["transform"];
	float spincoeff = (*dict)["spincoeff"];

	Transform soln = refalin3d_perturbquat(t,spincoeff,(float)n0,(float)n1,(float)n2,(float)x,(float)y,(float)z);

	EMData *tmp = this_img->process("xform",Dict("transform",&soln));
	Cmp* c = (Cmp*) ((void*)(*dict)["cmp"]);
	double result = c->cmp(tmp,with);
	if ( tmp != 0 ) delete tmp;
	delete t; t = 0;
	//cout << result << endl;
	return result;
}

EMData* Refine3DAlignerQuaternion::align(EMData * this_img, EMData *to,
	const string & cmp_name, const Dict& cmp_params) const
{
	
	if (!to || !this_img) throw NullPointerException("Input image is null"); // not sure if this is necessary, it was there before I started

	if (to->get_ndim() != 3 || this_img->get_ndim() != 3) throw ImageDimensionException("The Refine3D aligner only works for 3D images");

#ifdef EMAN2_USING_CUDA 
	if(EMData::usecuda == 1) {
		if(!this_img->getcudarwdata()) this_img->copy_to_cuda();
		if(!to->getcudarwdata()) to->copy_to_cuda();
	}
#endif

	float sdi = 0.0;
	float sdj = 0.0;
	float sdk = 0.0;
	float sdx = 0.0;
	float sdy = 0.0;
	float sdz = 0.0;
	bool mirror = false;
	
	Transform* t;
	if (params.has_key("xform.align3d") ) {
		// Unlike the 2d refine aligner, this class doesn't require the starting transform's
		// parameters to form the starting guess. Instead the Transform itself
		// is perturbed carefully (using quaternion rotation) to overcome problems that arise
		// when you use orthogonally-based Euler angles
		t = params["xform.align3d"];
	}else {
		t = new Transform(); // is the identity
	}
	
	float spincoeff =  params.set_default("spin_coeff",10.0f); // spin coefficient, controls speed of convergence (sort of)
	
	int np = 6; // the number of dimensions
	Dict gsl_params;
	gsl_params["this"] = this_img;
	gsl_params["with"] = to;
	gsl_params["snr"]  = params["snr"];
	gsl_params["mirror"] = mirror;
	gsl_params["transform"] = t;	
	gsl_params["spincoeff"] = spincoeff;
	Dict altered_cmp_params(cmp_params);
	
	const gsl_multimin_fminimizer_type *T = gsl_multimin_fminimizer_nmsimplex;
	gsl_vector *ss = gsl_vector_alloc(np);
	
	float stepi = params.set_default("stepi",1.0f); // doesn't really matter b/c the vecor part will be normalized anyway
	float stepj = params.set_default("stepj",1.0f); // doesn't really matter b/c the vecor part will be normalized anyway
	float stepk = params.set_default("stepk",1.0f); // doesn't really matter b/c the vecor part will be normalized anyway
	float stepx = params.set_default("stepx",1.0f);
	float stepy = params.set_default("stepy",1.0f);
	float stepz = params.set_default("stepz",1.0f);
	
	//gsl_vector_set(ss, 0, stepw);
	gsl_vector_set(ss, 0, stepi);
	gsl_vector_set(ss, 1, stepj);
	gsl_vector_set(ss, 2, stepk);
	gsl_vector_set(ss, 3, stepx);
	gsl_vector_set(ss, 4, stepy);
	gsl_vector_set(ss, 5, stepz);
	
	gsl_vector *x = gsl_vector_alloc(np);
	gsl_vector_set(x, 0, sdi);
	gsl_vector_set(x, 1, sdj);
	gsl_vector_set(x, 2, sdk);
	gsl_vector_set(x, 3, sdx);
	gsl_vector_set(x, 4, sdy);
	gsl_vector_set(x, 5, sdz);
	
	gsl_multimin_function minex_func;
	Cmp *c = Factory < Cmp >::get(cmp_name, altered_cmp_params);
		
	gsl_params["cmp"] = (void *) c;
	minex_func.f = &refalifn3dquat;

	minex_func.n = np;
	minex_func.params = (void *) &gsl_params;
	
	gsl_multimin_fminimizer *s = gsl_multimin_fminimizer_alloc(T, np);
	gsl_multimin_fminimizer_set(s, &minex_func, x, ss);
	
	int rval = GSL_CONTINUE;
	int status = GSL_SUCCESS;
	int iter = 1;
	
	float precision = params.set_default("precision",0.01f);
	int maxiter = params.set_default("maxiter",100);
	while (rval == GSL_CONTINUE && iter < maxiter) {
		iter++;
		status = gsl_multimin_fminimizer_iterate(s);
		if (status) {
			break;
		}
		rval = gsl_multimin_test_size(gsl_multimin_fminimizer_size(s), precision);
	}

	int maxshift = params.set_default("maxshift",-1);

	if (maxshift <= 0) {
		maxshift = this_img->get_xsize() / 4;
	}
	float fmaxshift = static_cast<float>(maxshift);
	
	EMData *result;
	if ( fmaxshift >= (float)gsl_vector_get(s->x, 0) && fmaxshift >= (float)gsl_vector_get(s->x, 1)  && fmaxshift >= (float)gsl_vector_get(s->x, 2))
	{
		float n0 = (float)gsl_vector_get(s->x, 0);
		float n1 = (float)gsl_vector_get(s->x, 1);
		float n2 = (float)gsl_vector_get(s->x, 2);
		float x = (float)gsl_vector_get(s->x, 3);
		float y = (float)gsl_vector_get(s->x, 4);
		float z = (float)gsl_vector_get(s->x, 5);
		
		Transform tsoln = refalin3d_perturbquat(t,spincoeff,n0,n1,n2,x,y,z);
			
		result = this_img->process("xform",Dict("transform",&tsoln));
		result->set_attr("xform.align3d",&tsoln);
		result->set_attr("score", result->cmp(cmp_name,to,cmp_params));
		
	 //coda goes here
	} else { // The refine aligner failed - this shift went beyond the max shift
		result = this_img->process("xform",Dict("transform",t));
		result->set_attr("xform.align3d",t);
	}
	
	//EMData *result = this_img->process("xform",Dict("transform",t));
	delete t;
	t = 0;
	gsl_vector_free(x);
	gsl_vector_free(ss);
	gsl_multimin_fminimizer_free(s);

	if ( c != 0 ) delete c;
	return result;
}

EMData*Refine3DAlignerGrid::align(EMData * this_img, EMData *to,
	const string & cmp_name, const Dict& cmp_params) const
{
	if ( this_img->get_ndim() != 3 || to->get_ndim() != 3 ) {
		throw ImageDimensionException("This aligner only works for 3D images");
	}

	Transform* t;
	if (params.has_key("xform.align3d") ) {
		// Unlike the 2d refine aligner, this class doesn't require the starting transform's
		// parameters to form the starting guess. Instead the Transform itself
		// is perturbed carefully (using quaternion rotation) to overcome problems that arise
		// when you use orthogonally-based Euler angles
		t = params["xform.align3d"];
	}else {
		t = new Transform(); // is the identity
	}
	
	int searchx = 0;
	int searchy = 0;
	int searchz = 0;
	
	bool dotrans = params.set_default("dotrans",1);
	if (params.has_key("search")) {
		vector<string> check;
		check.push_back("searchx");
		check.push_back("searchy");
		check.push_back("searchz");
		for(vector<string>::const_iterator cit = check.begin(); cit != check.end(); ++cit) {
			if (params.has_key(*cit)) throw InvalidParameterException("The search parameter is mutually exclusive of the searchx, searchy, and searchz parameters");
		}
		int search  = params["search"];
		searchx = search;
		searchy = search;
		searchz = search;
	} else {
		searchx = params.set_default("searchx",3);
		searchy = params.set_default("searchy",3);
		searchz = params.set_default("searchz",3);
	}	
	
	float delta = params.set_default("delta",1.0f);
	float range = params.set_default("range",10.0f);
	bool verbose = params.set_default("verbose",false);
	
	bool tomography = (cmp_name == "ccc.tomo") ? 1 : 0;
	EMData * tofft = 0;
	if(dotrans || tomography){
		tofft = to->do_fft();
	}
	
#ifdef EMAN2_USING_CUDA 
	if(EMData::usecuda == 1) {
		if(!this_img->isrodataongpu()) this_img->copy_to_cudaro();
		if(!to->getcudarwdata()) to->copy_to_cuda();
		if(to->getcudarwdata()){if(tofft) tofft->copy_to_cuda();}
	}
#endif

	Dict d;
	d["type"] = "eman"; // d is used in the loop below
	Dict best;
	best["score"] = 0.0f;
	bool use_cpu = true;
	Transform tran = Transform();
	for ( float alt = 0; alt < range; alt += delta) {
		// now compute a sane az step size 
		float saz = 360;
		if(alt != 0) saz = delta/sin(alt*M_PI/180.0f); // This gives consistent az step sizes(arc lengths)
		for ( float az = 0; az < 360; az += saz ){
			if (verbose) {
				cout << "Trying angle alt " << alt << " az " << az << endl;
			}
			// account for any changes in az
			for( float phi = -range-az; phi < range-az; phi += delta ) {
				d["alt"] = alt;
				d["phi"] = phi; 
				d["az"] = az;
				Transform tr(d);
				tr = tr*(*t);	// compose transforms, this moves to the pole (aprox)
				
				EMData* transformed = this_img->process("xform",Dict("transform",&tr));
				
				//need to do things a bit diffrent if we want to compare two tomos
				float score = 0.0f;
				if(dotrans || tomography){
					EMData* ccf = transformed->calc_ccf(tofft);
#ifdef EMAN2_USING_CUDA	
					if(to->getcudarwdata()){
						use_cpu = false;
						CudaPeakInfo* data = calc_max_location_wrap_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize(), searchx, searchy, searchz);
						tran.set_trans((float)-data->px, (float)-data->py, (float)-data->pz);
						//CudaPeakInfoFloat* data = calc_max_location_wrap_intp_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize(), searchx, searchy, searchz);
						//tran.set_trans(-data->xintp, -data->yintp, -data->zintp);
						tr = tran*tr;
						if (tomography) {
							float2 stats = get_stats_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize());
							score = -(data->peak - stats.x)/sqrt(stats.y); // Normalize, this is better than calling the norm processor since we only need to normalize one point
						} else {
							score = -data->peak;
						}
						delete data;
					}
#endif
					if(use_cpu){
						if(tomography) ccf->process_inplace("normalize");
						//vector<float> fpoint = ccf->calc_max_location_wrap_intp(searchx,searchy,searchz);
						//tran.set_trans(-fpoint[0], -fpoint[1], -fpoint[2]);
						//score = -fpoint[3];
						IntPoint point = ccf->calc_max_location_wrap(searchx,searchy,searchz);
						tran.set_trans((float)-point[0], (float)-point[1], (float)-point[2]);
						score = -ccf->get_value_at_wrap(point[0], point[1], point[2]);
						tr = tran*tr;
						
					}
					delete ccf; ccf =0;
					delete transformed; transformed = 0;// this is to stop a mem leak
				}

				if(!tomography){
					if(!transformed) transformed = this_img->process("xform",Dict("transform",&tr)); // we are returning a map
					score = transformed->cmp(cmp_name,to,cmp_params); //this is not very efficient as it creates a new cmp object for each iteration
					delete transformed; transformed = 0;// this is to stop a mem leak
				}
				
				if(score < float(best["score"])) {
					best["score"] = score;
					best["xform.align3d"] = &tr; // I wonder if this will cause a mem leak?
				} 	
			}
		}
	}

	if(tofft) {delete tofft; tofft = 0;}
	
	//make aligned map;
	EMData* best_match = this_img->process("xform",Dict("transform", best["xform.align3d"])); // we are returning a map
	best_match->set_attr("xform.align3d", best["xform.align3d"]);
	best_match->set_attr("score", float(best["score"]));
	
	//debug....
	Transform* zz = best_match->get_attr("xform.align3d");
	Vec3f zzz = zz->get_trans();
	cout << "x " << float(zzz[0]) << " y " << float(zzz[1]) << " z " << float(zzz[2]) << endl;
	
	return best_match;
	
}

EMData* RT3DGridAligner::align(EMData * this_img, EMData *to, const string & cmp_name, const Dict& cmp_params) const
{

	vector<Dict> alis = xform_align_nbest(this_img,to,1,cmp_name,cmp_params);

	Dict t;
	Transform* tr = (Transform*) alis[0]["xform.align3d"];
	t["transform"] = tr;
	EMData* soln = this_img->process("xform",t);
	soln->set_attr("xform.align3d",tr);
	delete tr; tr = 0;

	return soln;

}

vector<Dict> RT3DGridAligner::xform_align_nbest(EMData * this_img, EMData * to, const unsigned int nsoln, const string & cmp_name, const Dict& cmp_params) const {

	if ( this_img->get_ndim() != 3 || to->get_ndim() != 3 ) {
		throw ImageDimensionException("This aligner only works for 3D images");
	}

	int searchx = 0;
	int searchy = 0;
	int searchz = 0;
	
	bool dotrans = params.set_default("dotrans",1);
	if (params.has_key("search")) {
		vector<string> check;
		check.push_back("searchx");
		check.push_back("searchy");
		check.push_back("searchz");
		for(vector<string>::const_iterator cit = check.begin(); cit != check.end(); ++cit) {
			if (params.has_key(*cit)) throw InvalidParameterException("The search parameter is mutually exclusive of the searchx, searchy, and searchz parameters");
		}
		int search  = params["search"];
		searchx = search;
		searchy = search;
		searchz = search;
	} else {
		searchx = params.set_default("searchx",3);
		searchy = params.set_default("searchy",3);
		searchz = params.set_default("searchz",3);
	}

	float lalt = params.set_default("alt0",0.0f);
	float laz = params.set_default("az0",0.0f);
	float lphi = params.set_default("phi0",0.0f);
	float ualt = params.set_default("alt1",180.0f); // I am using 179.9 rather than 180 to avoid resampling
	float uphi = params.set_default("phi1",360.0f); // I am using 359.9 rather than 180 to avoid resampling 0 = 360 (for perodic functions)
	float uaz = params.set_default("az1",360.0f);   // I am using 359.9 rather than 180 to avoid resampling 0 = 360 (for perodic functions)
	float dalt = params.set_default("dalt",10.f);
	float daz = params.set_default("daz",10.f);
	float dphi = params.set_default("dphi",10.f);
	bool verbose = params.set_default("verbose",false);
	
	//in case we arre aligning tomos
	Dict altered_cmp_params(cmp_params);
	if (cmp_name == "ccc.tomo") {
                altered_cmp_params.set_default("searchx", searchx);
		altered_cmp_params.set_default("searchy", searchy);
		altered_cmp_params.set_default("searchz", searchz);
		altered_cmp_params.set_default("norm", true);
	}

	vector<Dict> solns;
	if (nsoln == 0) return solns; // What was the user thinking?
	for (unsigned int i = 0; i < nsoln; ++i ) {
		Dict d;
		d["score"] = 1.e24;
		Transform t; // identity by default
		d["xform.align3d"] = &t; // deep copy is going on here
		solns.push_back(d);
	}
	
	bool tomography = (cmp_name == "ccc.tomo") ? 1 : 0;
	EMData * tofft = 0;
	if(dotrans || tomography){
		tofft = to->do_fft();
	}
	
#ifdef EMAN2_USING_CUDA 
	if(EMData::usecuda == 1) {
		if(!this_img->isrodataongpu()) this_img->copy_to_cudaro();
		if(!to->getcudarwdata()) to->copy_to_cuda();
		if(to->getcudarwdata()){if(tofft) tofft->copy_to_cuda();}
	}
#endif

	Dict d;
	d["type"] = "eman"; // d is used in the loop below
	Transform trans = Transform();
	bool use_cpu = true;
	for ( float alt = lalt; alt <= ualt; alt += dalt) {
		// An optimization for the range of az is made at the top of the sphere
		// If you think about it, this is just a coarse way of making this approach slightly more efficient
		for ( float az = laz; az < uaz; az += daz ){
			if (verbose) {
				cout << "Trying angle alt " << alt << " az " << az << endl;
			}
			for( float phi = lphi; phi < uphi; phi += dphi ) {
				d["alt"] = alt;
				d["phi"] = phi; 
				d["az"] = az;
				Transform t(d);
				EMData* transformed = this_img->process("xform",Dict("transform",&t));
				
				//need to do things a bit diffrent if we want to compare two tomos
				float best_score = 0.0f;
				if(dotrans || tomography){
					EMData* ccf = transformed->calc_ccf(tofft);
#ifdef EMAN2_USING_CUDA	
					if(to->getcudarwdata()){
						use_cpu = false;;
						CudaPeakInfo* data = calc_max_location_wrap_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize(), searchx, searchy, searchz);
						trans.set_trans((float)-data->px, (float)-data->py, (float)-data->pz);
						t = trans*t;	//composite transfrom
						if (tomography) {
							float2 stats = get_stats_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize());
							best_score = -(data->peak - stats.x)/sqrt(stats.y); // Normalize, this is better than calling the norm processor since we only need to normalize one point
						} else {
							best_score = -data->peak;
						}
						delete data;
					}
#endif
					if(use_cpu){
						if(tomography) ccf->process_inplace("normalize");	
						IntPoint point = ccf->calc_max_location_wrap(searchx,searchy,searchz);
						trans.set_trans((float)-point[0], (float)-point[1], (float)-point[2]);
						t = trans*t;	//composite transfrom
						best_score = -ccf->get_value_at_wrap(point[0], point[1], point[2]);
					}
					delete ccf; ccf =0;
					delete transformed; transformed = 0;
				}

				if(!tomography){
					if(!transformed) transformed = this_img->process("xform",Dict("transform",&t));
					best_score = transformed->cmp(cmp_name,to,cmp_params); //this is not very efficient as it creates a new cmp object for each iteration
					delete transformed; transformed = 0;
				}
				
				unsigned int j = 0;
				for ( vector<Dict>::iterator it = solns.begin(); it != solns.end(); ++it, ++j ) {
					if ( (float)(*it)["score"] > best_score ) {  // Note greater than - EMAN2 preferes minimums as a matter of policy
						vector<Dict>::reverse_iterator rit = solns.rbegin();
						copy(rit+1,solns.rend()-j,rit);
						Dict& d = (*it);
						d["score"] = best_score;
						d["xform.align3d"] = &t;
						break;
					}
				}
			}
		}
	}

	if(tofft) {delete tofft; tofft = 0;}
	return solns;

}

EMData* RT3DSphereAligner::align(EMData * this_img, EMData *to, const string & cmp_name, const Dict& cmp_params) const
{

	vector<Dict> alis = xform_align_nbest(this_img,to,1,cmp_name,cmp_params);

	Dict t;
	Transform* tr = (Transform*) alis[0]["xform.align3d"];
	t["transform"] = tr;
	EMData* soln = this_img->process("xform",t);
	soln->set_attr("xform.align3d",tr);
	delete tr; tr = 0;

	return soln;

}

vector<Dict> RT3DSphereAligner::xform_align_nbest(EMData * this_img, EMData * to, const unsigned int nsoln, const string & cmp_name, const Dict& cmp_params) const {

	if ( this_img->get_ndim() != 3 || to->get_ndim() != 3 ) {
		throw ImageDimensionException("This aligner only works for 3D images");
	}

	int searchx = 0;
	int searchy = 0;
	int searchz = 0;
         
	bool dotrans = params.set_default("dotrans",1);
	if (params.has_key("search")) {
		vector<string> check;
		check.push_back("searchx");
		check.push_back("searchy");
		check.push_back("searchz");
		for(vector<string>::const_iterator cit = check.begin(); cit != check.end(); ++cit) {
			if (params.has_key(*cit)) throw InvalidParameterException("The search parameter is mutually exclusive of the searchx, searchy, and searchz parameters");
		}
		int search  = params["search"];
		searchx = search;
		searchy = search;
		searchz = search;
	} else {
		searchx = params.set_default("searchx",3);
		searchy = params.set_default("searchy",3);
		searchz = params.set_default("searchz",3);
	}

	float lphi = params.set_default("phi0",0.0f);
	float uphi = params.set_default("phi1",360.0f);
	float dphi = params.set_default("dphi",10.f);
	float threshold = params.set_default("threshold",0.f);
	if (threshold < 0.0f) throw InvalidParameterException("The threshold parameter must be greater than or equal to zero");
	bool verbose = params.set_default("verbose",false);
	
	//in case we arre aligning tomos
	Dict altered_cmp_params(cmp_params);
	if (cmp_name == "ccc.tomo") {
                altered_cmp_params.set_default("searchx", searchx);
		altered_cmp_params.set_default("searchy", searchy);
		altered_cmp_params.set_default("searchz", searchz);
		altered_cmp_params.set_default("norm", true);
	}

	vector<Dict> solns;
	if (nsoln == 0) return solns; // What was the user thinking?
	for (unsigned int i = 0; i < nsoln; ++i ) {
		Dict d;
		d["score"] = 1.e24;
		Transform t; // identity by default
		d["xform.align3d"] = &t; // deep copy is going on here
		solns.push_back(d);
	}

	Dict d;
	d["inc_mirror"] = true; // This should probably always be true for 3D case. If it ever changes we might have to make inc_mirror a parameter
	if ( params.has_key("delta") && params.has_key("n") ) {
		throw InvalidParameterException("The delta and n parameters are mutually exclusive in the RT3DSphereAligner aligner");
	} else if ( params.has_key("n") ) {
		d["n"] = params["n"];
	} else {
		// If they didn't specify either then grab the default delta - if they did supply delta we're still safe doing this
		d["delta"] = params.set_default("delta",10.f);
	}

	if ((string)params.set_default("orientgen","eman")=="eman") d["perturb"]=0;
	Symmetry3D* sym = Factory<Symmetry3D>::get((string)params.set_default("sym","c1"));
	vector<Transform> transforms = sym->gen_orientations((string)params.set_default("orientgen","eman"),d);

	bool tomography = (cmp_name == "ccc.tomo") ? 1 : 0;
	
	//precompute fixed FT, saves a LOT of time!!!
	EMData * this_imgfft = 0;
	if(dotrans || tomography){
		this_imgfft = this_img->do_fft();
	}
	
	
#ifdef EMAN2_USING_CUDA 
	if(EMData::usecuda == 1) {
		cout << "Using CUDA for 3D alignment" << endl;
		if(!to->isrodataongpu()) to->copy_to_cudaro();
		if(!this_img->getcudarwdata()) this_img->copy_to_cuda();
		if(this_imgfft) this_imgfft->copy_to_cuda();
	}
#endif

	Transform trans = Transform();
	bool use_cpu = true;
	for(vector<Transform>::const_iterator trans_it = transforms.begin(); trans_it != transforms.end(); trans_it++) {
		Dict params = trans_it->get_params("eman");
		Transform t(params);
		if (verbose) {
			float alt = params["alt"];
			float az = params["az"];
			cout << "Trying angle alt: " << alt << " az: " << az << endl;
		}

		for( float phi = lphi; phi < uphi; phi += dphi ) { 
			
			params["phi"] = phi;
			t.set_rotation(params);
			EMData* transformed = to->process("xform",Dict("transform",&t));
			
			//need to do things a bit diffrent if we want to compare two tomos
			float best_score = 0.0f;
			if(dotrans || tomography){
				EMData* ccf = transformed->calc_ccf(this_imgfft);
#ifdef EMAN2_USING_CUDA	
				if(this_img->getcudarwdata()){
					use_cpu = false;;
					CudaPeakInfo* data = calc_max_location_wrap_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize(), searchx, searchy, searchz);
					trans.set_trans((float)-data->px, (float)-data->py, (float)-data->pz);
					t = trans*t;	//composite transform
					if (tomography) {
						float2 stats = get_stats_cuda(ccf->getcudarwdata(), ccf->get_xsize(), ccf->get_ysize(), ccf->get_zsize());
						best_score = -(data->peak - stats.x)/sqrt(stats.y); // Normalize, this is better than calling the norm processor since we only need to normalize one point
					} else {
						best_score = -data->peak;
					}
					delete data;
				}
#endif
				if(use_cpu){
					if(tomography) ccf->process_inplace("normalize");
					IntPoint point = ccf->calc_max_location_wrap(searchx,searchy,searchz);
					trans.set_trans((float)-point[0], (float)-point[1], (float)-point[2]);
					t = trans*t;	//composite transform
					best_score = -ccf->get_value_at_wrap(point[0], point[1], point[2]);
				}
				delete ccf; ccf =0;
				delete transformed; transformed = 0;// this is to stop a mem leak
			}

			if(!tomography){
				if(!transformed) transformed = to->process("xform",Dict("transform",&t));
				best_score = transformed->cmp(cmp_name,this_img,cmp_params); //this is not very efficient as it creates a new cmp object for each iteration
				delete transformed; transformed = 0;
			}

			unsigned int j = 0;
			//cout << "alt " <<float(t.get_rotation("eman").get("alt")) << " az " << float(t.get_rotation("eman").get("az")) << " phi " << float(t.get_rotation("eman").get("phi")) << endl;
			for ( vector<Dict>::iterator it = solns.begin(); it != solns.end(); ++it, ++j ) {
				if ( (float)(*it)["score"] > best_score ) { // Note greater than - EMAN2 preferes minimums as a matter of policy
					vector<Dict>::reverse_iterator rit = solns.rbegin();
					copy(rit+1,solns.rend()-j,rit);
					Dict& d = (*it);
					d["score"] = best_score;
					t.invert(); //We actually moved the ref onto the moving, so we need to invert to do the opposite(this is done b/c the ref is aligned to the sym axis, whereas the mvoing is not)
					d["xform.align3d"] = &t; // deep copy is going on here
					break;
				}
			}

		}
	}
	delete sym; sym = 0;
	if(this_imgfft) {delete this_imgfft; this_imgfft = 0;}
	return solns;

}

//Could refactor the code here......(But not really woth it)
EMData* RT3DSymmetryAligner::align(EMData * this_img, EMData *to, const string & cmp_name, const Dict& cmp_params) const
{

	vector<Dict> alis = xform_align_nbest(this_img,to,1,cmp_name,cmp_params);

	Dict t;
	Transform* tr = (Transform*) alis[0]["xform.align3d"];
	t["transform"] = tr;
	EMData* soln = this_img->process("xform",t);
	soln->set_attr("xform.align3d",tr);
	delete tr; tr = 0;

	return soln;

}

vector<Dict> RT3DSymmetryAligner::xform_align_nbest(EMData * this_img, EMData * to, const unsigned int nsoln, const string & cmp_name, const Dict& cmp_params) const 
{
	
	bool verbose = params.set_default("verbose",false);
	//Initialize a soln dict
	vector<Dict> solns;
	if (nsoln == 0) return solns; // What was the user thinking?
	for (unsigned int i = 0; i < nsoln; ++i ) {
		Dict d;
		d["score"] = 1.e24;
		Transform t; // identity by default
		d["xform.align3d"] = &t; // deep copy is going on here
		solns.push_back(d);
	}
	
	//Genrate symmetry related orritenations
	vector<Transform> syms = Symmetry3D::get_symmetries((string)params.set_default("sym","icos"));
	
	float score = 0.0f;
	for ( vector<Transform>::const_iterator symit = syms.begin(); symit != syms.end(); ++symit ) {
		Transform sympos = *symit; //stupidly this is necessary!!!
		//Here move to sym position and compute the score
		EMData* transformed = this_img->process("xform",Dict("transform",&sympos));
		score = transformed->cmp(cmp_name,this_img,cmp_params);
		delete transformed; transformed = 0;
		
		if (verbose) {
			Dict rots = sympos.get_rotation("eman");
			cout <<"Score is: " << score << " az " << float(rots["az"]) << " alt " << float(rots["alt"]) << " phi " << float(rots["phi"]) << endl;
		}
		
		unsigned int j = 0;
		for ( vector<Dict>::iterator it = solns.begin(); it != solns.end(); ++it, ++j ) {
			if ( (float)(*it)["score"] > score ) { // Note greater than - EMAN2 preferes minimums as a matter of policy
				vector<Dict>::reverse_iterator rit = solns.rbegin();
				copy(rit+1,solns.rend()-j,rit);
				Dict& d = (*it);
				d["score"] = score;
				d["xform.align3d"] = &sympos; // deep copy is going on here
				break;
			}
		}
	}
	return solns;
}

namespace {
float frm_2d_Align(EMData *this_img, EMData *to, float *frm2dhhat, EMData* selfpcsfft, int p_max_input,int rsize, float &com_this_x, float &com_this_y, float &com_with_x, float &com_with_y,const string & cmp_name, const Dict& cmp_params)
{
	int size=rsize;
	float dx,dy;
	int bw=size/2;
	int MAXR=this_img->get_ysize()/2;
	//int MAXR=size;
	unsigned long tsize=2*size;
	unsigned long ind1=0, ind2=0, ind3=0, ind4=0, ind41=0;
	unsigned long index0=0;
	int i=0, j=0, m=0, n=0, r=0;
	int loop_rho=0, rho_best=0;

 	float* gnr2   = new float[size*2];
 	float* maxcor = new float[size+1];                  // MAXR need change

 	int p_max=p_max_input;
	float* result = new float[5*(p_max+1)];
	float* cr=new float[size*(bw+1)];
	float* ci=new float[size*(bw+1)];
	EMData *data_in=new EMData;
	data_in->set_complex(true);
	data_in->set_fftodd(false);
	data_in->set_ri(true);
	data_in->set_size(size+2,size,1);
	float *in=data_in->get_data();

	float *self_sampl_fft = selfpcsfft->get_data(); // ming f(r)

	float maxcor_sofar=0.0f;
	int p=0;

	for(p=0; p<=p_max; ++p){
		ind1=p*size*bw;
		for (i=0;i<size;++i)
			for (j=0;j<bw+1;++j){
				cr[i*(bw+1)+j]=0.0;
				ci[i*(bw+1)+j]=0.0;
			}
    	for(n=0;n<bw;++n){                                // loop for n
    		ind2=(ind1+n);
      		index0=n*(bw+1);
			for(r=0;r<=MAXR;++r) {
      			ind3=(ind2+r*bw)*size;
      			for(m=0;m<size;m++){              // take back hat{h(n,r,p)}(m)
      				ind4=(ind3+m)*2;
				    ind41=ind4+1;
				    gnr2[2*m]=frm2dhhat[ind4];
				    gnr2[2*m+1]=frm2dhhat[ind41];
				}
      			for(m=0;m<bw;++m){
					float tempr=self_sampl_fft[2*m+r*(size+2)]*r;
      				float tempi=self_sampl_fft[2*m+1+r*(size+2)]*r;
      				float gnr2_r=gnr2[2*m];
      				float gnr2_i=gnr2[2*m+1];
      				cr[n*(bw+1)+m]+=gnr2_r*tempr+gnr2_i*tempi;
					ci[n*(bw+1)+m]+=gnr2_i*tempr-gnr2_r*tempi;
					if(n!=0){					// m,-n
      				   	if(m!= 0){
				      		int ssize=tsize-2*m;	// ssize = 2*size-2m
				      		int ssize1=ssize+1;
				      		float gnr2_r=gnr2[ssize];
				      		float gnr2_i=gnr2[ssize1];
					   		cr[(size-n)*(bw+1)+m]+=gnr2_r*tempr-gnr2_i*tempi;
				      		ci[(size-n)*(bw+1)+m]-=gnr2_i*tempr+gnr2_r*tempi;
				      	}
				   		else{
				   			cr[(size-n)*(bw+1)+m]+=*(gnr2)*tempr-*(gnr2+1)*tempi;
				   			ci[(size-n)*(bw+1)+m]-=*(gnr2+1)*tempr+*(gnr2)*tempi;
				   		}
			       	}
				}
			}
        }
    	for (int cii=0; cii<size*(bw+1);++cii){
    			in[2*cii]=cr[cii];
    			in[2*cii+1]=ci[cii];
    			//printf("cii=%d,in[2i+1]=%f\n",cii, cr[cii]);
    	}

    	EMData *data_out;
		data_out=data_in->do_ift();
		float *c=data_out->get_data();
		float tempr=0.0f, corre_fcs=999.0f;

  	    int n_best=0, m_best=0;
        float temp=-100.0f;
  		for(n=0;n<size;++n){// move Tri_2D to Tri = c(phi,phi';rho)
  		  	for(m=0;m<size;++m){
				temp=c[n*size+m];
				if(temp>tempr) {
					tempr=temp;
					n_best=n;
					m_best=m;
				}
  		   	}
  		}
  		delete data_out;

  		float corre,Phi2,Phi,Tx,Ty,Vx, Vy;

  		//for (n_best=0;n_best<bw;n_best++)
  		  //  for (m_best=0;m_best<2*bw;m_best++){
  		//n_best=0;
  		//m_best=70;
  		Phi2=n_best*M_PI/bw;  // ming this is reference image rotation angle
  		Phi=m_best*M_PI/bw;   // ming this is particle image rotation angle
  		Vx=p*cos(Phi);//should use the angle of the centered one
  		Vy=-p*sin(Phi);
  		Tx=Vx+(floor(com_this_x+0.5f)-floor(com_with_x+0.5f));
  		Ty=Vy+(floor(com_this_y+0.5f)-floor(com_with_y+0.5f));

  		dx=-Tx;	// the Rota & Trans value (Tx,Ty, ang_keep) are for the projection image,
  		dy=-Ty;	// need to convert to raw image

  		EMData *this_tmp=this_img->copy();//ming change to to
		this_tmp->rotate(-(Phi2-Phi)*180.0f,0.0f,0.0f);
		this_tmp->translate(dx,dy,0.0);

		corre=this_tmp->cmp(cmp_name,to,cmp_params);
		//printf("corre=%f\n",corre);
		delete this_tmp;
		if(corre<=corre_fcs) { //ming, cmp use smaller value stands for more similarity
			corre_fcs=corre;
			result[0+5*p] = float(p);	// rho
			result[1+5*p] = corre;		// correlation_fcs
			result[2+5*p] = (Phi2-Phi)*180.0f;	// rotation angle
			result[3+5*p] = Tx;		// Translation_x
			result[4+5*p] = Ty;		// Translation_y
		}
		maxcor[p]=corre_fcs;               		//  maximum correlation for current rho
		if(corre_fcs<maxcor_sofar) {
			maxcor_sofar=corre_fcs;   		// max correlation up to current rho
		    rho_best=p;				// the rho value with maxinum correlation value
		}
		if(p>=4){
			if(maxcor[p] < maxcor[p-1] && maxcor[p-1] < maxcor[p-2]&& maxcor[p-2] < maxcor[p-3] && maxcor[p-3] < maxcor[p-4]){
				loop_rho=1;
				break; //exit p loop
			}
		}
	} // end for p
	//}//test my method
	if(loop_rho == 1)
		p=p+1;
	int rb5=5*rho_best;
	float fsc      = result[1+rb5];
	float ang_keep = result[2+rb5];
	float Tx       = result[3+rb5];
	float Ty       = result[4+rb5];
	delete[] gnr2;
	delete[] maxcor;
	delete[] result;
	delete cr;
	cr=0;
	delete ci;
	ci=0;
	delete data_in; // ming add
	dx = -Tx;		// the Rota & Trans value (Tx,Ty, ang_keep) are for the projection image,
	dy = -Ty;		// need to convert to raw image
	this_img->rotate(-ang_keep,0,0); // ming change this to this_img??
	this_img->translate(dx,dy,0.0); // ming change this to this_img


	Transform  tsoln(Dict("type","2d","alpha",ang_keep));
	tsoln.set_trans(dx,dy);
	this_img->set_attr("xform.align2d",&tsoln);
#ifdef DEBUG
	float fsc_best=this_img->cmp(cmp_name,to,cmp_params);
	printf("rho_best=%d fsc=%f fsc_best=%f dx=%f dy=%f ang_keep=%f com_withx=%f com_selfx=%f com_selfy=%f\n",rho_best,fsc,fsc_best,dx,dy,ang_keep,com_with_x,com_this_x,com_this_y);
#endif
	return fsc;     // return the fsc coefficients
} // FRM2D aligner sub_class
} // end namespace


EMData *FRM2DAligner::align(EMData * this_img, EMData * to,
			const string & cmp_name, const Dict& cmp_params) const
{
	if (!this_img) {
		return 0;
	}
	if (to && !EMUtil::is_same_size(this_img, to))
		throw ImageDimensionException("Images must be the same size to perform translational alignment");

	int nx=this_img->get_xsize();
	int ny=this_img->get_ysize();
	int size =(int)floor(M_PI*ny/4.0);
	size =Util::calc_best_fft_size(size);//ming   bestfftsize(size);
	int MAXR=ny/2;
	//int MAXR=size;
	EMData *this_temp=this_img->copy(); // ming change avg to to
	FloatPoint com_test,com_test1;
	com_test=this_temp->calc_center_of_mass();//ming add
	float com_this_x=com_test[0];
	float com_this_y=com_test[1];
	delete this_temp;


	EMData *that_temp=to->copy();
	com_test1=that_temp->calc_center_of_mass();
	float com_with_x=com_test1[0];
	float com_with_y=com_test1[1];
	delete that_temp;

	EMData *avg_frm=to->copy();
	float dx,dy;
	//float dx=-(com_with_x-nx/2); //ming
	//float dy=-(com_with_y-ny/2); //ming
	//avg_frm->translate(dx,dy,0.0);
	EMData *withpcs=avg_frm->unwrap_largerR(0,MAXR,size,float(MAXR)); // ming, something wrong inside this subroutine
	//EMData *withpcs=avg_frm->unwrap(-1,-1,-1,0,0,1);
	EMData *withpcsfft=withpcs->oneDfftPolar(size, float(MAXR), float(MAXR));

	float *sampl_fft=withpcsfft->get_data(); //
	delete avg_frm;
	delete withpcs;

	int bw=size/2;
	unsigned long ind1=0, ind2=0, ind3=0, ind4=0, ind41=0;
	float pi2=2.0*M_PI, r2;

	EMData *data_in=new EMData;
	data_in->set_complex(true);
	data_in->set_ri(1);
	data_in->set_size(2*size,1,1);
	float * comp_in=data_in->get_data();

	int p_max=3;
	float *frm2dhhat=0;

	if( (frm2dhhat=(float *)malloc((p_max+1)*(size+2)*bw*size*2* sizeof(float)))==NULL){
		cout <<"Error in allocating memory 13. \n";
		exit(1);
	}
	//printf("p_max=%d\n",p_max);
	float *sb=0, *cb=0;		// sin(beta) and cos(beta) for get h_hat, 300>size
	if((sb=new float[size])==NULL||(cb=new float[size])==NULL) {
		cout <<"can't allocate more memory, terminating. \n";
		exit(1);
	}
	for(int i=0;i<size;++i) {        // beta sampling, to calculate beta' and r'
		float beta=i*M_PI/bw;
	   	sb[i]=sin(beta);
	   	cb[i]=cos(beta);
	}

	for(int p=0; p<=p_max; ++p){
		ind1=p*size*bw;
    	float pp2=(float)(p*p);
   		for(int n=0;n<bw;++n){         /* loop for n */
    		ind2=ind1+n;
      		for(int r=0;r<=MAXR;++r) {
				ind3=(ind2+r*bw)*size;
        		float rr2=(float)(r*r);
				float rp2=(float)(r*p);
       			for(int i=0;i<size;++i){                            // beta sampling, to get beta' and r'
       				r2=std::sqrt((float)(rr2+pp2-2.0*rp2*cb[i]));   // r2->r'
       		 		int r1=(int)floor(r2+0.5f);                        // for computing gn(r')
       				if(r1>MAXR){
       					comp_in[2*i]=0.0f;
       					comp_in[2*i+1]=0.0f;
       				}
       				else{
       					float gn_r=sampl_fft[2*n+r1*(size+2)];           // real part of gn(r')
       					float gn_i=sampl_fft[2*n+1+r1*(size+2)];           // imaginary part of gn(r')
						float sb2, cb2, cn, sn;
						if(n!=0){
							if(r2 != 0.0){
								sb2=r*sb[i]/r2;
								cb2=(r*cb[i]-p)/r2;
							}
        					else{
								sb2=0.0;
								cb2=1.0;
							}
        					if(sb2>1.0) sb2= 1.0f;
        					if(sb2<-1.0)sb2=-1.0f;
        					if(cb2>1.0) cb2= 1.0f;
        					if(cb2<-1.0)cb2=-1.0f;
        					float beta2=atan2(sb2,cb2);
        					if(beta2<0.0) beta2+=pi2;
        					float nb2=n*beta2;
        					cn=cos(nb2);
							sn=sin(nb2);
						}
        				else{
							cn=1.0f; sn=0.0f;
						}
						comp_in[2*i]=cn*gn_r-sn*gn_i;
						comp_in[2*i+1]=-(cn*gn_i+sn*gn_r);
        			}
        		}
       			EMData *data_out;
        		data_out=data_in->do_fft();
        		float * comp_out=data_out->get_data();
        		for(int m=0;m<size;m++){                                     // store hat{h(n,r,p)}(m)
					ind4=(ind3+m)*2;
					ind41=ind4+1;
					frm2dhhat[ind4]=comp_out[2*m];
					frm2dhhat[ind41]=comp_out[2*m+1];
				}
        		delete data_out;
			}
		}
	}

	delete[] sb;
	delete[] cb;
	delete data_in;
	delete withpcsfft;

	float dot_frm0=0.0f, dot_frm1=0.0f;
	EMData *da_nFlip=0, *da_yFlip=0, *dr_frm=0;
	//dr_frm=this_img->copy();
	for (int iFlip=0;iFlip<=1;++iFlip){
		if (iFlip==0){dr_frm=this_img->copy(); 	da_nFlip=this_img->copy();}
		else {dr_frm=this_img->copy(); da_yFlip=this_img->copy();}
		if(iFlip==1) {com_this_x=nx-com_this_x; } //ming   // image mirror about Y axis, so y keeps the same

		dx=-(com_this_x-nx/2); //ming
		dy=-(com_this_y-ny/2); //ming
		dr_frm->translate(dx,dy,0.0); // this
		EMData *selfpcs = dr_frm->unwrap_largerR(0,MAXR,size, (float)MAXR);
		//EMData *selfpcs=dr_frm->unwrap(-1,-1,-1,0,0,1);
		EMData *selfpcsfft = selfpcs->oneDfftPolar(size, (float)MAXR, (float)MAXR);
		delete selfpcs;
		delete dr_frm;
		if(iFlip==0)
			dot_frm0=frm_2d_Align(da_nFlip,to, frm2dhhat, selfpcsfft, p_max, size, com_this_x, com_this_y, com_with_x, com_with_y,cmp_name,cmp_params);
		else
			dot_frm1=frm_2d_Align(da_yFlip,to, frm2dhhat, selfpcsfft, p_max, size, com_this_x, com_this_y, com_with_x, com_with_y,cmp_name,cmp_params);
		delete selfpcsfft;
	}

	delete[] frm2dhhat;
	if(dot_frm0 <=dot_frm1) {
#ifdef DEBUG
		printf("best_corre=%f, no flip\n",dot_frm0);
#endif
		delete da_yFlip;
		return da_nFlip;
	}
	else {
#ifdef DEBUG
		printf("best_corre=%f, flipped\n",dot_frm1);
#endif
		delete da_nFlip;
		return da_yFlip;
	}
}

#ifdef SPARX_USING_CUDA

CUDA_Aligner::CUDA_Aligner(int id) {
	image_stack = NULL;
	image_stack_filtered = NULL;
	ccf = NULL;
	if (id != -1) cudasetup(id);
}

void CUDA_Aligner::finish() {
	if (image_stack) free(image_stack);
	if (image_stack_filtered) free(image_stack_filtered);
	if (ccf) free(ccf);
	image_stack = NULL;
	image_stack_filtered = NULL;
	ccf = NULL;
}

void CUDA_Aligner::setup(int nima, int nx, int ny, int ring_length, int nring, int ou, float step, int kx, int ky, bool ctf) {

	NIMA = nima;
	NX = nx;
	NY = ny;
	RING_LENGTH = ring_length;
        NRING = nring;
	STEP = step;
	KX = kx;
	KY = ky;
	OU = ou;
	CTF = ctf;
	
	image_stack = (float *)malloc(NIMA*NX*NY*sizeof(float));
	if (CTF == 1) image_stack_filtered = (float *)malloc(NIMA*NX*NY*sizeof(float));
	ccf = (float *)malloc(2*(2*KX+1)*(2*KY+1)*NIMA*(RING_LENGTH+2)*sizeof(float));
}

void CUDA_Aligner::insert_image(EMData *image, int num) {

	int base_address = num*NX*NY;

	for (int y=0; y<NY; y++)
		for (int x=0; x<NX; x++)
			image_stack[base_address+y*NX+x] = (*image)(x, y);
}

void CUDA_Aligner::filter_stack(vector<float> ctf_params) {
	
	float *params;
	
	params = (float *)malloc(NIMA*6*sizeof(float));	
	
	for (int i=0; i<NIMA*6; i++) params[i] = ctf_params[i];

	filter_image(image_stack, image_stack_filtered, NIMA, NX, NY, params);

	free(params);
}

void CUDA_Aligner::sum_oe(vector<float> ctf_params, vector<float> ali_params, EMData *ave1, EMData *ave2) {
	
	float *ctf_p, *ali_p, *av1, *av2;
	
	ctf_p = (float *)malloc(NIMA*6*sizeof(float));
	ali_p = (float *)malloc(NIMA*4*sizeof(float));
	
	if (CTF == 1) {
		for (int i=0; i<NIMA*6; i++)  ctf_p[i] = ctf_params[i];
	}
	for (int i=0; i<NIMA*4; i++)   ali_p[i] = ali_params[i];
	
	av1 = ave1->get_data();
	av2 = ave2->get_data();
	
	rot_filt_sum(image_stack, NIMA, NX, NY, CTF, ctf_p, ali_p, av1, av2);
	
	free(ctf_p);
	free(ali_p);
}

vector<float> CUDA_Aligner::alignment_2d(EMData *ref_image_em, vector<float> sx_list, vector<float> sy_list, int silent) {

	float *ref_image, max_ccf;
	int base_address, ccf_offset;
	float ts, tm;
	float ang, sx = 0, sy = 0, mirror, co, so, sxs, sys;
	float *sx2, *sy2;
	vector<float> align_result;

	sx2 = (float *)malloc(NIMA*sizeof(float));
	sy2 = (float *)malloc(NIMA*sizeof(float));

	ref_image = ref_image_em->get_data();
	
	for (int i=0; i<NIMA; i++) {
		sx2[i] = sx_list[i];
		sy2[i] = sy_list[i];
	}
	
	if (CTF == 1) {
		calculate_ccf(image_stack_filtered, ref_image, ccf, NIMA, NX, NY, RING_LENGTH, NRING, OU, STEP, KX, KY, sx2, sy2, silent);
	} else {
		calculate_ccf(image_stack, ref_image, ccf, NIMA, NX, NY, RING_LENGTH, NRING, OU, STEP, KX, KY, sx2, sy2, silent);
	}

	ccf_offset = NIMA*(RING_LENGTH+2)*(2*KX+1)*(2*KY+1);

	for (int im=0; im<NIMA; im++) {
		max_ccf = -1.0e22;
		for (int kx=-KX; kx<=KX; kx++) {
			for (int ky=-KY; ky<=KY; ky++) {
				base_address = (((ky+KY)*(2*KX+1)+(kx+KX))*NIMA+im)*(RING_LENGTH+2);
				for (int l=0; l<RING_LENGTH; l++) {
					ts = ccf[base_address+l];
					tm = ccf[base_address+l+ccf_offset];
					if (ts > max_ccf) {
						ang = float(l)/RING_LENGTH*360.0;
						sx = -kx*STEP;
						sy = -ky*STEP;
						mirror = 0;
						max_ccf = ts;
					}
					if (tm > max_ccf) {
						ang = float(l)/RING_LENGTH*360.0; 
						sx = -kx*STEP;
						sy = -ky*STEP;
						mirror = 1;
						max_ccf = tm;
					}
				}
			}
		}
		co =  cos(ang*M_PI/180.0);
		so = -sin(ang*M_PI/180.0);
		sxs = sx*co - sy*so;
		sys = sx*so + sy*co;

		align_result.push_back(ang);
		align_result.push_back(sxs);
		align_result.push_back(sys);
		align_result.push_back(mirror);
	}
	
	free(sx2);
	free(sy2);
	
	return align_result;
}


vector<float> CUDA_Aligner::ali2d_single_iter(EMData *ref_image_em, vector<float> ali_params, float csx, float csy, int silent, float delta) {

	float *ref_image, max_ccf;
	int base_address, ccf_offset;
	float ts, tm;
	float ang = 0.0, sx = 0.0, sy = 0.0, co, so, sxs, sys;
	int mirror;
	float *sx2, *sy2;
	vector<float> align_result;

	sx2 = (float *)malloc(NIMA*sizeof(float));
	sy2 = (float *)malloc(NIMA*sizeof(float));

	ref_image = ref_image_em->get_data();
	
	for (int i=0; i<NIMA; i++) {
		ang = ali_params[i*4]/180.0*M_PI;
		sx = (ali_params[i*4+3] < 0.5)?(ali_params[i*4+1]-csx):(ali_params[i*4+1]+csx);
		sy = ali_params[i*4+2]-csy;
		co = cos(ang);
		so = sin(ang);
		sx2[i] = -(sx*co-sy*so);
		sy2[i] = -(sx*so+sy*co);
	}
	
	if (CTF == 1) {
		calculate_ccf(image_stack_filtered, ref_image, ccf, NIMA, NX, NY, RING_LENGTH, NRING, OU, STEP, KX, KY, sx2, sy2, silent);
	} else {
		calculate_ccf(image_stack, ref_image, ccf, NIMA, NX, NY, RING_LENGTH, NRING, OU, STEP, KX, KY, sx2, sy2, silent);
	}

	ccf_offset = NIMA*(RING_LENGTH+2)*(2*KX+1)*(2*KY+1);

	float sx_sum = 0.0f;
	float sy_sum = 0.0f;

	int dl;
	dl = static_cast<int>(delta/360.0*RING_LENGTH);
	if (dl<1) { dl = 1; }	
	
	for (int im=0; im<NIMA; im++) {
		max_ccf = -1.0e22;
		for (int kx=-KX; kx<=KX; kx++) {
			for (int ky=-KY; ky<=KY; ky++) {
				base_address = (((ky+KY)*(2*KX+1)+(kx+KX))*NIMA+im)*(RING_LENGTH+2);
				for (int l=0; l<RING_LENGTH; l+=dl) {
					ts = ccf[base_address+l];
					tm = ccf[base_address+l+ccf_offset];
					if (ts > max_ccf) {
						ang = float(l)/RING_LENGTH*360.0;
						sx = -kx*STEP;
						sy = -ky*STEP;
						mirror = 0;
						max_ccf = ts;
					}
					if (tm > max_ccf) {
						ang = float(l)/RING_LENGTH*360.0; 
						sx = -kx*STEP;
						sy = -ky*STEP;
						mirror = 1;
						max_ccf = tm;
					}
				}
			}
		}
		co =  cos(ang*M_PI/180.0);
		so = -sin(ang*M_PI/180.0);
		
		sxs = (sx-sx2[im])*co-(sy-sy2[im])*so;
		sys = (sx-sx2[im])*so+(sy-sy2[im])*co;

		//if (sxs*sxs+sys*sys >= 7*7) { sxs=0; sys=0; }

		align_result.push_back(ang);
		align_result.push_back(sxs);
		align_result.push_back(sys);
		align_result.push_back(mirror);
		
		if (mirror == 0)  { sx_sum += sxs; }  else { sx_sum -= sxs; }
		sy_sum += sys;
	}
	
	align_result.push_back(sx_sum);
	align_result.push_back(sy_sum);
	
	free(sx2);
	free(sy2);
	
	return align_result;
}


CUDA_multiref_aligner::CUDA_multiref_aligner(int id) {
	image_stack = NULL;
	ref_image_stack = NULL;
	ref_image_stack_filtered = NULL;
	ccf = NULL;
	ctf_params = NULL;
	ali_params = NULL;
	cudasetup(id);
}


void CUDA_multiref_aligner::finish() {
	if (image_stack) free(image_stack);
	if (ref_image_stack) free(ref_image_stack);
	if (ref_image_stack_filtered) free(ref_image_stack_filtered);
	if (ccf) free(ccf);
	if (ctf_params) free(ctf_params);
	if (ali_params) free(ali_params);
	image_stack = NULL;
	ref_image_stack = NULL;
	ref_image_stack_filtered = NULL;
	ccf = NULL;
	ctf_params = NULL;
	ali_params = NULL;
}	

void CUDA_multiref_aligner::setup(int nima, int nref, int nx, int ny, int ring_length, int nring, int ou, float step, int kx, int ky, bool ctf) {

	NIMA = nima;
	NREF = nref;
	NX = nx;
	NY = ny;
	RING_LENGTH = ring_length;
        NRING = nring;
	STEP = step;
	KX = kx;
	KY = ky;
	OU = ou;
	CTF = ctf;
	// This number can be increased according to the GPU memory. But my tests has shown the speedup 
	// is limited (~5%) even if I increased the size 10 times, so it's better to be on the safe side.
	MAX_IMAGE_BATCH = 10;
	
	image_stack = (float *)malloc(NIMA*NX*NY*sizeof(float));
	ref_image_stack = (float *)malloc(NREF*NX*NY*sizeof(float));
	if (CTF == 1) ref_image_stack_filtered = (float *)malloc(NREF*NX*NY*sizeof(float));
	ccf = (float *)malloc(2*(2*KX+1)*(2*KY+1)*NREF*(RING_LENGTH+2)*MAX_IMAGE_BATCH*sizeof(float));
}

void CUDA_multiref_aligner::setup_params(vector<float> all_ali_params, vector<float> all_ctf_params) {
	
	ali_params = (float *)malloc(NIMA*4*sizeof(float));
	for (int i=0; i<NIMA*4; i++)   ali_params[i] = all_ali_params[i];
	if (CTF == 1) {
		ctf_params = (float *)malloc(NIMA*6*sizeof(float));
		for (int i=0; i<NIMA*6; i++)  ctf_params[i] = all_ctf_params[i];
	}
}

void CUDA_multiref_aligner::insert_image(EMData *image, int num) {

	int base_address = num*NX*NY;

	for (int y=0; y<NY; y++)
		for (int x=0; x<NX; x++)
			image_stack[base_address+y*NX+x] = (*image)(x, y);
}

void CUDA_multiref_aligner::insert_ref_image(EMData *image, int num) {

	int base_address = num*NX*NY;

	for (int y=0; y<NY; y++)
		for (int x=0; x<NX; x++)
			ref_image_stack[base_address+y*NX+x] = (*image)(x, y);
}

vector<float> CUDA_multiref_aligner::multiref_ali2d(int silent) {

	float *ctf_params_ref = (float *)malloc(NREF*6*sizeof(float));	
	float *sx2 = (float *)malloc(NIMA*sizeof(float));
	float *sy2 = (float *)malloc(NIMA*sizeof(float));
	vector<float> align_results;
	int ccf_offset = NREF*(RING_LENGTH+2)*(2*KX+1)*(2*KY+1);

	vector<int> batch_size;
	vector<int> batch_begin;
	
	if (CTF == 1) {
		float previous_defocus = ctf_params[0];
		int current_size = 1;
		for (int i=1; i<NIMA; i++) {
			if (ctf_params[i*6] != previous_defocus || current_size >= MAX_IMAGE_BATCH) {
				batch_size.push_back(current_size);
				current_size = 1;
				previous_defocus = ctf_params[i*6];
			} else current_size++;			
		}
		batch_size.push_back(current_size);
	} else {
		batch_size.resize(NIMA/MAX_IMAGE_BATCH, MAX_IMAGE_BATCH);
		if (NIMA%MAX_IMAGE_BATCH != 0)  batch_size.push_back(NIMA%MAX_IMAGE_BATCH);
	}
	int num_batch = batch_size.size();
	batch_begin.resize(num_batch, 0);
	for (int i=1; i<num_batch; i++) batch_begin[i] = batch_size[i-1]+batch_begin[i-1];
	assert(batch_begin[num_batch-1]+batch_size[num_batch-1] == NIMA-1);

	for (int i=0; i<NIMA; i++) {
		float ang = ali_params[i*4]/180.0*M_PI;
		float sx = ali_params[i*4+1];
		float sy = ali_params[i*4+2];
		float co = cos(ang);
		float so = sin(ang);
		sx2[i] = -(sx*co-sy*so);
		sy2[i] = -(sx*so+sy*co);
	}

	for (int i=0; i<num_batch; i++) {
		if (CTF == 1) {
			for (int p=0; p<NREF; p++)
				for (int q=0; q<6; q++)
					ctf_params_ref[p*6+q] = ctf_params[batch_begin[i]*6+q];
			filter_image(ref_image_stack, ref_image_stack_filtered, NREF, NX, NY, ctf_params_ref);
			calculate_multiref_ccf(image_stack+batch_begin[i]*NX*NY, ref_image_stack_filtered, ccf, batch_size[i], NREF, NX, NY, RING_LENGTH, NRING, OU, STEP, KX, KY,
				sx2+batch_begin[i], sy2+batch_begin[i], silent);
		} else {
			calculate_multiref_ccf(image_stack+batch_begin[i]*NX*NY, ref_image_stack, ccf, batch_size[i], NREF, NX, NY, RING_LENGTH, NRING, OU, STEP, KX, KY,
				sx2+batch_begin[i], sy2+batch_begin[i], silent);
		}

		for (int j=0; j<batch_size[i]; j++) {
			for (int im=0; im<NREF; im++) {
				float max_ccf = -1.0e22;
				float ang = 0.0, sx = 0.0, sy = 0.0;
				int mirror = 0;
				for (int kx=-KX; kx<=KX; kx++) {
					for (int ky=-KY; ky<=KY; ky++) {
						int base_address = (((ky+KY)*(2*KX+1)+(kx+KX))*NREF+im)*(RING_LENGTH+2)+ccf_offset*2*j;			
						for (int l=0; l<RING_LENGTH; l++) {
							float ts = ccf[base_address+l];
							float tm = ccf[base_address+l+ccf_offset];
							if (ts > max_ccf) {
								ang = 360.0-float(l)/RING_LENGTH*360.0;
								sx = -kx*STEP;
								sy = -ky*STEP;
								mirror = 0;
								max_ccf = ts;
							}
							if (tm > max_ccf) {
								ang = float(l)/RING_LENGTH*360.0; 
								sx = -kx*STEP;
								sy = -ky*STEP;
								mirror = 1;
								max_ccf = tm;
							}
						}
					}
				}
				float co =  cos(ang*M_PI/180.0);
				float so = -sin(ang*M_PI/180.0);
		
				int img_num = batch_begin[i]+j;
				float sxs = (sx-sx2[img_num])*co-(sy-sy2[img_num])*so;
				float sys = (sx-sx2[img_num])*so+(sy-sy2[img_num])*co;

				align_results.push_back(max_ccf);
				align_results.push_back(ang);
				align_results.push_back(sxs);
				align_results.push_back(sys);
				align_results.push_back(mirror);
			}
		}
	}
	
	free(ctf_params_ref);
	free(sx2);
	free(sy2);
	
	return align_results;
}

#endif


void EMAN::dump_aligners()
{
	dump_factory < Aligner > ();
}

map<string, vector<string> > EMAN::dump_aligners_list()
{
	return dump_factory_list < Aligner > ();
}
